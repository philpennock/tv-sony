#!/usr/bin/env python3

"""
tv: control living-room TV

The Sony TV has a JSON REST-ish RPC interface.  We can call it.
We enter a REPL if no parameters are provided.

Beware that digits on the remote do not enter ASCII digits but some other
unicode digits.

Beware that encryption keys are not very securely managed, but I think it's
about appropriate for use as a TV remote, since I don't want to have to enter a
password to talk to the TV.  So we have a `changeme` level non-secret used as
a tiny obfuscation layer for local storage.  Since we're already storing the PIN
to talk to the TV in clear-text on disk, there's no worse vulnerability here.
"""

__author__ = 'phil@pennock-tech.com (Phil Pennock)'

import argparse
import base64
import collections
from dataclasses import dataclass
import html
import inspect
import json
import os
import pathlib
import re
import readline
import secrets
import shlex
import sys
import time
import traceback
import typing

# TV can encrypt text strings, which we want for sending/reading passwords in app prompts
import cryptography.hazmat.backends
import cryptography.hazmat.primitives
import cryptography.hazmat.primitives.padding
# import cryptography.hazmat.primitives.asymmetric.rsa
# Sane HTTP
import requests

if sys.stdout.isatty():
    import curses
    import pygments
    import pygments.lexers
    import pygments.formatters

if sys.version_info < (3, 6):
    raise Exception('Need at least Python 3.6 for this tool')
    # pathlib, f-strings

SCRIPT_DIR = pathlib.Path(__file__).absolute().parent

# FIXME: this is not fully XDG-compliant
_APP_NAME = pathlib.Path('tv')
_HOME_DIR = _APP_NAME.home()


def _xdg_dir(varname: str, home_rel_default: typing.Sequence[str]) -> pathlib.Path:
    ps = os.getenv(varname, None)
    if ps is None:
        p = _HOME_DIR
        for n in home_rel_default:
            p = p / n
    else:
        p = pathlib.Path(ps)
    return p / _APP_NAME


_CONFIG_DIR = _xdg_dir('XDG_CONFIG_HOME', ('.config',))      # read files: default.pin and default.hostname
_CACHE_DIR = _xdg_dir('XDG_CACHE_HOME', ('.cache',))         # keep a copy of the TV's public key for encryption
_DATA_DIR = _xdg_dir('XDG_DATA_HOME', ('.local', 'share',))  # keep our local private/public keys for encryption
_DEFAULT_TV = 'default'

DEF_USERAGENT = 'tv/0.2 (Phil Pennock)'
# This exists just for local disk and might as well be the empty string, but I
# don't want to fight APIs any more, so this is one generated password which
# I'm leaving in source, on the basis that it's like bouncycastle's "changeme"
# string: a password that's not a password, just a known serialization
# constant:
PRIVATE_KEY_PASSWORD = b'Wh#2#*4zbWBH0_o4x,Ad'


class Error(Exception):
    """Base class for exceptions from tv."""
    pass


class VolumeSpecParseError(Error):
    """Unparseable volume specification."""
    pass


class Exit(Exception):
    """Base class for exceptions which exit without a stack trace."""
    pass


class BadInput(Exit):
    """Exceptions indicating bad user input."""
    pass


# InfraRed Compatible Control data from the TV, for the SOAP interface
IRCCKeyCode = collections.namedtuple('IRCCKeyCode', ['KeyName', 'Rawcode'])

# Readline context management
# If IsCommandSet we will switch; if false, we need to figure out what to do
# differently.
# If Swallow, it takes all remaining args instead of having sub commands.
# MapSubCommands lets us build a tree.
RLContext = collections.namedtuple('RLContext', ['Name', 'IsCommandSet', 'Swallow', 'MapSubCommands'])


@dataclass
class WrapCrypto:
    backend: typing.Any = cryptography.hazmat.backends.default_backend()
    DER: typing.Any = cryptography.hazmat.primitives.serialization.Encoding.DER
    PEM: typing.Any = cryptography.hazmat.primitives.serialization.Encoding.PEM
    PKCS1: typing.Any = cryptography.hazmat.primitives.serialization.PublicFormat.PKCS1
    PKCS7: typing.Any = cryptography.hazmat.primitives.padding.PKCS7
    PKCS8: typing.Any = cryptography.hazmat.primitives.serialization.PrivateFormat.PKCS8
    SPKI: typing.Any = cryptography.hazmat.primitives.serialization.PublicFormat.SubjectPublicKeyInfo
    AES: typing.Any = cryptography.hazmat.primitives.ciphers.algorithms.AES
    CBC: typing.Any = cryptography.hazmat.primitives.ciphers.modes.CBC
    PKCS1v15: typing.Any = cryptography.hazmat.primitives.asymmetric.padding.PKCS1v15
    PrivateRaw: typing.Any = cryptography.hazmat.primitives.serialization.PrivateFormat.Raw
    Cipher: typing.Any = cryptography.hazmat.primitives.ciphers.Cipher
    # NoEncryption apparently does not satisfy KeySerializationEncryption
    # I want one fixed serialization type so I can safely load, but
    # cryptography only lets me have access to the mutable curated choice.
    BestAvailableEncryption: typing.Any = cryptography.hazmat.primitives.serialization.BestAvailableEncryption
    want_exponent: int = 65537
    want_keysize: int = 2048
    AES_BLOCKSIZE_BITS: int = 128
    AES_BLOCKSIZE_U8: int = 16


Crypto = WrapCrypto()


class SymKey:
    AES_KEY: typing.Optional[bytes] = None
    AES_IV: typing.Optional[bytes] = None

    def __init__(self):
        if SymKey.AES_KEY is None:
            SymKey.AES_KEY = secrets.token_bytes(Crypto.AES_BLOCKSIZE_U8)
        if SymKey.AES_IV is None:
            SymKey.AES_IV = secrets.token_bytes(Crypto.AES_BLOCKSIZE_U8)
        self.aes_key = SymKey.AES_KEY
        self.aes_iv = SymKey.AES_IV
        SymKey.AES_IV = (int.from_bytes(SymKey.AES_IV, byteorder='big') + 1).to_bytes(Crypto.AES_BLOCKSIZE_U8, byteorder='big')
        self.cipher = Crypto.Cipher(Crypto.AES(self.aes_key), Crypto.CBC(self.aes_iv), backend=Crypto.backend)

    def common_key(self) -> bytes:
        return self.aes_key + b':' + self.aes_iv

    def encKey(self, pubKey: cryptography.hazmat.primitives.asymmetric.rsa.RSAPublicKey) -> str:
        return base64.b64encode(pubKey.encrypt(
            self.common_key(),
            Crypto.PKCS1v15(),
        )).decode('ASCII')

    def encrypt(self, data: str) -> str:
        padder = Crypto.PKCS7(Crypto.AES_BLOCKSIZE_BITS).padder()
        padded = padder.update(data.encode('utf-8'))
        padded += padder.finalize()
        enc = self.cipher.encryptor()
        return base64.b64encode(enc.update(padded) + enc.finalize()).decode('ASCII')

    def decrypt(self, data: str) -> str:
        dec = self.cipher.decryptor()
        padded = dec.update(data) + dec.finalize()
        unpadder = Crypto.PKCS7(Crypto.AES_BLOCKSIZE_BITS).unpadder()
        return (unpadder.update(padded) + unpadder.finalize()).encode('utf-8')


class Config:
    """Our storage system and local RSA key mgmt."""

    PIN_OPTION, PIN_FILEEXT = 'pin', 'pin'
    HOST_OPTION, HOST_FILEEXT = 'host', 'hostname'

    def __init__(self, options: argparse.Namespace) -> None:
        self.options = options
        # .tv is the config name as given, often 'default
        # .real_tv is the actual name, use this to write files
        self.tv = self.options.tv
        self.tv_pin = self.derive_field(Config.PIN_OPTION, Config.PIN_FILEEXT)
        self.tv_host = self.derive_field(Config.HOST_OPTION, Config.HOST_FILEEXT)
        self.using_default = self.tv == _DEFAULT_TV
        if self.using_default:
            self.real_tv = self._find_real_tvname()
        else:
            self.real_tv = self.tv
        self.our_rsakey: typing.Optional[cryptography.hazmat.primitives.asymmetric.rsa.RSAPublicKey] = None
        self.aes_iv: typing.Optional[bytes] = None
        self.aes_key: typing.Optional[bytes] = None
        self.max_age_app_cache = 24 * 3600

    def derive_field(self, optname: str, base: str) -> str:
        t = getattr(self.options, optname)
        if t:
            return t
        return self.read_config(base)

    def read_config(self, base: str) -> str:
        fn = _CONFIG_DIR / (self.options.tv + '.' + base)
        return fn.read_text().strip()

    def _find_real_tvname(self) -> str:
        default_pin_file = _CONFIG_DIR / (_DEFAULT_TV + '.' + Config.PIN_FILEEXT)
        return default_pin_file.resolve().stem

    @property
    def readline_config(self) -> pathlib.Path:
        return _CONFIG_DIR / 'readline.conf'

    @property
    def tv_keyfile(self) -> pathlib.Path:
        return _CACHE_DIR / (self.real_tv + '.tv.rsa.pub')

    @property
    def tv_ircc_codes_file(self) -> pathlib.Path:
        return _CACHE_DIR / (self.real_tv + '.ircc-codes.json')

    @property
    def readline_history(self) -> pathlib.Path:
        return _CACHE_DIR / (self.real_tv + '.readline.history')

    @property
    def app_list_file(self) -> pathlib.Path:
        return _CACHE_DIR / (self.real_tv + '.apps.json')

    @property
    def our_public_keyfile(self) -> pathlib.Path:
        return _DATA_DIR / 'our.rsa.pub'

    @property
    def our_private_keyfile(self) -> pathlib.Path:
        return _DATA_DIR / 'our.rsa.private'

    def persist_current(self, new_tvname: str) -> None:
        # A name of '' will write out to current
        write_name = new_tvname if new_tvname else self.real_tv
        forbidden = [os.path.sep, os.path.pathsep]
        if os.path.extsep:
            forbidden += [os.path.extsep]
        if True in [c in write_name for c in forbidden]:
            raise Error(f'bad characters in {write_name!r}')

        # We will write the derived merged values, so can modify an existing TV to a new name.

        if not _CONFIG_DIR.exists():
            _CONFIG_DIR.mkdir(mode=0o700, parents=True)

        if write_name == _DEFAULT_TV:
            write_name = _DEFAULT_TV + '-real'
        pin_file = _CONFIG_DIR / (write_name + '.' + Config.PIN_FILEEXT)
        host_file = _CONFIG_DIR / (write_name + '.' + Config.HOST_FILEEXT)
        # Don't update defaults until both named entries have been written
        for f, content in [(pin_file, self.tv_pin), (host_file, self.tv_host)]:
            if f.exists():
                f.unlink()
            f.touch(mode=0o600, exist_ok=False)
            f.write_text(content + '\n', encoding='utf-8')
        self.set_default_tv(write_name)

    def set_default_tv(self, target_tvname: str) -> None:
        # We have no locking here, so not safe against a concurrent reader.
        # For myself now, I don't currently care.
        default_pin_file = _CONFIG_DIR / (_DEFAULT_TV + '.' + Config.PIN_FILEEXT)
        default_host_file = _CONFIG_DIR / (_DEFAULT_TV + '.' + Config.HOST_FILEEXT)
        pin_file = _CONFIG_DIR / (target_tvname + '.' + Config.PIN_FILEEXT)
        host_file = _CONFIG_DIR / (target_tvname + '.' + Config.HOST_FILEEXT)
        if not pin_file.exists():
            raise BadInput(f"can't repoint default TV to {target_tvname!r}, missing {pin_file.name!r}")
        if not host_file.exists():
            raise BadInput(f"can't repoint default TV to {target_tvname!r}, missing {host_file.name!r}")
        for src, dest in [(default_pin_file, pin_file), (default_host_file, host_file)]:
            if src.exists() and not src.is_symlink():
                src.rename(src.with_suffix('.old' + src.suffix))
            if src.exists() or src.is_symlink():
                src.unlink()
            src.symlink_to(dest.name)

    def load_pubkey_b64(self, b64data: str) -> cryptography.hazmat.primitives.asymmetric.rsa.RSAPublicKey:
        return self.load_pubkey_bin(base64.b64decode(b64data, validate=True))

    def load_pubkey_bin(self, bindata: bytes) -> cryptography.hazmat.primitives.asymmetric.rsa.RSAPublicKey:
        return cryptography.hazmat.primitives.serialization.load_der_public_key(bindata, backend=Crypto.backend)

    def make_rsa_key(self) -> cryptography.hazmat.primitives.asymmetric.rsa.RSAPrivateKey:
        return cryptography.hazmat.primitives.asymmetric.rsa.generate_private_key(
            public_exponent=Crypto.want_exponent,
            key_size=Crypto.want_keysize,
            backend=Crypto.backend)

    def write_file(self, fpath: pathlib.Path, data: bytes) -> None:
        if not fpath.parent.exists():
            fpath.parent.mkdir(0o700)
        if fpath.exists():
            saved = fpath.with_suffix('.old' + fpath.suffix)
            if saved.exists():
                saved.unlink()
            fpath.rename(saved)
        fpath.touch(mode=0o600, exist_ok=False)
        fpath.write_bytes(data)

    def save_our_private_key(self, rsakey: cryptography.hazmat.primitives.asymmetric.rsa.RSAPrivateKey) -> None:
        self.write_file(
            self.our_private_keyfile,
            rsakey.private_bytes(
                encoding=Crypto.PEM,
                format=Crypto.PKCS8,
                encryption_algorithm=Crypto.BestAvailableEncryption(PRIVATE_KEY_PASSWORD)),
        )

    def save_our_public_key(self, rsakey: cryptography.hazmat.primitives.asymmetric.rsa.RSAPrivateKey) -> None:
        # We don't use this ourselves, we do this so that other tooling can look at it if wanted.
        self.write_file(
            self.our_public_keyfile,
            rsakey.public_key().public_bytes(Crypto.PEM, Crypto.PKCS1),
        )

    def setup_thisremote_encryption(self, force_new_remote_key=False) -> None:
        if self.our_private_keyfile.exists() and not force_new_remote_key:
            self.our_rsakey = cryptography.hazmat.primitives.serialization.load_pem_private_key(
                self.our_private_keyfile.read_bytes(),
                password=PRIVATE_KEY_PASSWORD,
                backend=Crypto.backend)
        else:
            self.our_rsakey = self.make_rsa_key()
            self.save_our_public_key(self.our_rsakey)
            self.save_our_private_key(self.our_rsakey)

    def load_ircc_codes(self) -> typing.Dict:
        bare = json.load(open(self.tv_ircc_codes_file))
        typed: typing.Dict[str, IRCCKeyCode] = {}
        for k, p in bare.items():
            typed[k] = IRCCKeyCode(*p)
        return typed

    def save_ircc_codes(self, jdata: typing.Dict) -> None:
        with self.tv_ircc_codes_file.open('w') as wh:
            # sort to make git and diff saner, if we move from cache
            json.dump(jdata, wh, indent=1, sort_keys=True)


class Remote:
    """Talking to the TV via various protocols.

    Most of the stuff is REST API, but anything which is directly emulating a
    remote control is IRCC-IP (InfraRed Compatible Control over Internet Protocol),
    using SOAP XML.
    """

    def __init__(self, config: Config) -> None:
        self.options = config.options
        self.config = config
        self.next_id = 1
        self.addr = config.tv_host
        self.pin = config.tv_pin
        self._tv_pubkey_b64: typing.Optional[str] = None
        self._tv_pubkey_bin: typing.Optional[bytes] = None
        self._ircc_dict: typing.Optional[typing.Dict] = None
        self._setup_requests()

    def verbosity(self, n: int = 1) -> bool:
        return True if self.options.verbose >= n else False

    def verbose(self, message: str, level=1) -> None:
        if self.options.verbose < level:
            return
        print('[remote] '+message, file=sys.stderr, flush=True)

    def _setup_requests(self) -> None:
        self.session = requests.Session()
        self.session.headers['User-Agent'] = DEF_USERAGENT
        self.session.headers['X-Auth-PSK'] = self.pin

    def _send(self, service: str, method: str, params: typing.Dict, *, api_version='1.0'):
        url = f'http://{self.addr}/sony/{service}'
        payload_d = {
            'method': method,
            'version': api_version,
            'id': self.next_id,
            'params': [params] if params else [],
        }
        self.next_id += 1
        if self.verbosity(3):
            print(f'> POST <{url}> ', end='')
            pretty_print_json(payload_d)
        elif self.verbosity(2):
            print(f' >> {service} / {method}')
        r = self.session.post(url, json=payload_d)
        return r

    def send(self, service: str, method: str, params: typing.Dict, **kwargs) -> None:
        r = self._send(service, method, params, **kwargs)
        if self.verbosity():
            pretty_print_json(r.json())

    def query(self, service: str, method: str, params: typing.Dict, **kwargs) -> typing.Dict:
        res = self._send(service, method, params, **kwargs)
        if self.verbosity(3):
            print(f'< {res.status_code} {res.reason}')
            if self.verbosity(4):
                pretty_print_json(dict(res.headers))
            pretty_print_json(res.json())
        return res.json()

    def check_error(self, label: str, result: typing.Dict) -> None:
        if 'error' not in result:
            return
        code, message = result['error'][:2]
        raise Exit(f'failed in {label}: code {code} message: {message}')

    # <https://pro-bravia.sony.net/develop/integrate/rest-api/spec/>
    KNOWN_SERVICES = 'guide appControl audio avContent encryption system videoScreen'.split()

    def _get_power(self) -> str:
        resp = self.query('system', 'getPowerStatus', {})
        return resp['result'][0]['status']

    def _set_power(self, power_state: bool) -> None:
        self.send('system', 'setPowerStatus', {'status': power_state})

    power = property(_get_power, _set_power, None)

    def _set_mute(self, mute_state: bool) -> None:
        self.send('audio', 'setAudioMute', {'status': mute_state})

    mute = property(None, _set_mute, None)

    # this is paired with :playing, query_playing_content_info()
    # might build a map of uris to labels and try to simplify through that, for a better reader?
    def set_external_input(self, kind: str, port: str) -> None:
        uri = f'extInput:{kind}?port={port}'
        self.send('avContent', 'setPlayContent', {'uri': uri})

    def _get_volume(self) -> typing.List[typing.Dict]:
        resp = self.query('audio', 'getVolumeInformation', {})
        return resp['result'][0]

    def _set_volume(self, new_volume: str) -> None:
        # api 1.2 lets us control if the on-screen volume UI should be displayed; stick to 1.0, accept UI defaults
        self.send('audio', 'setAudioVolume', {'target': 'speaker', 'volume': new_volume})

    volume = property(_get_volume, _set_volume, None)

    def reboot(self) -> None:
        self.send('system', 'requestReboot', {})

    def list_apps(self) -> typing.List[str]:
        apps = self.query('appControl', 'getApplicationList', {})
        return [html.unescape(x['title']) for x in apps['result'][0]]

    def launch_app(self, appname: str) -> None:
        needle = appname.lower()
        res = self.query('appControl', 'getApplicationList', {})
        filtered = [app for app in res['result'][0] if html.unescape(app['title']).lower() == needle]
        if not filtered:
            raise BadInput(f'unknown app {appname!r}')
        if len(filtered) > 1:
            applist = ', '.join(map(lambda x: shlex.quote(html.unescape(x['title'])), filtered))
            raise BadInput(f'too many apps found for {appname!r}: {applist}')
        uri = filtered[0]['uri']
        self.send('appControl', 'setActiveApp', {'uri': uri})

    def list_inputs(self) -> typing.List[typing.Dict]:
        inputs = self.query('avContent', 'getCurrentExternalInputsStatus', {}, api_version='1.1')
        return inputs['result'][0]

    # All methods with names starting 'query_' are directly exposed by the
    # Commander as debug commands, specified with a leading colon,
    # thus `tv :query_time` works.

    def _query_show_json(self, *args, result_index=0, **kwargs) -> None:
        res = self.query(*args, **kwargs)
        self.check_error(inspect.stack()[1].function, res)
        pretty_print_json(res['result'][result_index])

    def query_supported_apis(self) -> None:
        self._query_show_json('guide', 'getSupportedApiInfo', {'services': Remote.KNOWN_SERVICES})

    def query_time(self) -> None:
        self._query_show_json('system', 'getCurrentTime', {}, api_version='1.1')

    def query_network_settings(self) -> None:
        # We shouldn't need netif per the spec, but we get "Illegal Argument" without it
        self._query_show_json('system', 'getNetworkSettings', {'netif': ''})

    def query_interface_information(self) -> None:
        self._query_show_json('system', 'getInterfaceInformation', {})

    def query_sound_settings(self) -> None:
        # Array, one for each target
        self._query_show_json('audio', 'getSoundSettings', {'target': ''}, api_version='1.1')

    def query_speaker_settings(self) -> None:
        # Array, one for each target
        self._query_show_json('audio', 'getSpeakerSettings', {'target': ''})

    def query_playing_content_info(self) -> None:
        self._query_show_json('avContent', 'getPlayingContentInfo', {})

    def setup_encryption(self, force_fetch=False, tv_only=False, **kwargs) -> None:
        if not tv_only:
            self.config.setup_thisremote_encryption(**kwargs)
        if self.config.tv_keyfile.exists() and not force_fetch:
            self._tv_pubkey_b64 = self.config.tv_keyfile.read_text().strip()
        else:
            kd = self.query('encryption', 'getPublicKey', {})
            self._tv_pubkey_b64 = kd['result'][0]['publicKey']
            if not self._tv_pubkey_b64:
                raise Exit('TV gave us an empty public key')
            if not self.config.tv_keyfile.parent.exists():
                self.config.tv_keyfile.parent.mkdir(0o700)
            self.config.tv_keyfile.write_text(self._tv_pubkey_b64 + '\n')
        self._tv_pubkey_bin = base64.b64decode(self._tv_pubkey_b64, validate=True)

    @property
    def tv_pubkey(self) -> cryptography.hazmat.primitives.asymmetric.rsa.RSAPublicKey:
        if self._tv_pubkey_bin is None:
            self.setup_encryption(tv_only=True)
            if self._tv_pubkey_bin is None:
                raise Error('still no pubkey bin after setting up encryption')
        return self.config.load_pubkey_bin(self._tv_pubkey_bin)

    def get_text_form(self) -> str:
        key = SymKey()
        encKey = key.encKey(self.tv_pubkey)
        res = self.query('appControl', 'getTextForm', {
            'encKey': encKey,
        }, api_version='1.1')
        self.check_error('get_text_form', res)
        encText = res['result'][0]['text']
        return key.decrypt(encText)

    def set_text_form(self, newText: str) -> None:
        key = SymKey()
        res = self.query('appControl', 'setTextForm', {
            'text': key.encrypt(newText),
            'encKey': key.encKey(self.tv_pubkey),
        }, api_version='1.1')
        self.check_error('set_text_form', res)
        if 'result' not in res:
            raise Error('missing result (expected empty but present) in set_text_form response')

    text = property(get_text_form, set_text_form, None)

    def _send_ircc_rawcode(self, rawcode: str) -> None:
        # <https://pro-bravia.sony.net/develop/integrate/ircc-ip/overview/index.html>
        url = f'http://{self.addr}/sony/ircc'
        soap_headers = {
            'Content-Type': 'text/xml; charset=UTF-8',
            'SOAPACTION': '"urn:schemas-sony-com:service:IRCC:1#X_SendIRCC"'
        }
        soap_payload_template = '''<s:Envelope
    xmlns:s="http://schemas.xmlsoap.org/soap/envelope/"
    s:encodingStyle="http://schemas.xmlsoap.org/soap/encoding/">
    <s:Body>
        <u:X_SendIRCC xmlns:u="urn:schemas-sony-com:service:IRCC:1">
            <IRCCCode>{0}</IRCCCode>
        </u:X_SendIRCC>
    </s:Body>
</s:Envelope>
'''
        self.verbose(f'_send_ircc_rawcode: SOAP IRCCCode {rawcode}', level=4)
        r = self.session.post(url,
                              data=soap_payload_template.format(rawcode),
                              headers=soap_headers)
        r.raise_for_status()
        return r

    def _setup_ircc(self):
        if self._ircc_dict is not None:
            return
        try:
            self._ircc_dict = self.config.load_ircc_codes()
            return
        except FileNotFoundError:
            pass
        r = self.query('system', 'getRemoteControllerInfo', {})
        self.check_error('getRemoteControllerInfo', r)
        # Ideally we'd have a handy case-insensitive dict, so we could store
        # preserving the capitalization but not worry for command entry.
        #
        # result[0] is deprecated; result[1] is list of objs, each with 'name' and 'value' keys
        codes = {}
        for pair in r['result'][1]:
            kp = pair['name']
            k = kp.lower()
            v = pair['value']
            if k in codes:
                self.verbose(f'duplicate IRCC code for {kp!r}: had: {codes[k]} also: {v}')
                continue
            codes[k] = IRCCKeyCode(kp, v)
        self.config.save_ircc_codes(codes)
        self._ircc_dict = codes

    # These _should_ be pre-empted by any actual key definitions of this name
    fallback_key_aliases = {
        'back': 'return',
        'select': 'confirm',
    }

    def key(self, keyname: str) -> None:
        self._setup_ircc()

        # Why Num 0-9,11,12 ?  Where's the love for 10?
        if len(keyname) == 1 and keyname.isdigit() or keyname in ('Num11', 'Num12',):
            keyname = 'Num' + keyname
        lk = keyname.lower()

        if lk not in self._ircc_dict:
            if lk in self.fallback_key_aliases and self.fallback_key_aliases[lk] in self._ircc_dict:
                new_lk = self.fallback_key_aliases[lk]
                print(f'tv key: alias fixup: {lk!r} -> {new_lk!r}', file=sys.stderr)
                lk = new_lk
            else:
                raise BadInput(f'unknown keycode {keyname!r}')
        self._send_ircc_rawcode(self._ircc_dict[lk].Rawcode)

    def known_keys(self) -> typing.List[str]:
        self._setup_ircc()
        keylist = [None] * len(self._ircc_dict)
        for i, k in enumerate(self._ircc_dict.keys()):
            keylist[i] = self._ircc_dict[k].KeyName
        return sorted(keylist)


class SubRepl(Exception):
    """Indicate that a different REPL needs to be entered."""
    # When this is raised, the string value is used to check for a method
    # on Commander to invoke.  "cli_body_"+str(SubRepl)
    pass


class Commander:
    """Command interpreter."""

    def __init__(self, remote: Remote, commands: typing.List[str]) -> None:
        self.options = remote.options
        self.remote = remote
        self.commands = commands
        self.vol_matcher = re.compile(r'^([+-])(\d+)\Z')
        self.repl = False

    def _completion_init(self):
        self._completion_populate_values()
        self._complete_previous = None
        self._complete_previous_ctx = ''
        self._complete_cache_prev = None
        self._completion_context_stack = []
        self._prior_completer = None
        self._prior_push_ctx = None

    def next(self, previous: str) -> str:
        try:
            return self.commands.pop(0)
        except IndexError as e:
            raise BadInput(f'parameter needed for command {previous!r}') from e

    def volume(self, spec: str, allow_absolute: bool) -> None:
        m = self.vol_matcher.match(spec)
        if m:
            if int(m.group(2)) > 10:
                raise BadInput('can only raise/lower by up to ±10')
            self.remote.volume = spec
            return

        if not allow_absolute:
            raise VolumeSpecParseError(f'unhandled volume spec {spec!r}')
        ivol = int(spec)
        if ivol > 100:
            raise BadInput('can only set volume to absolute 0..100')
        self.remote.volume = str(ivol)

    _command_typos = {
        'hmdi': 'hdmi',
    }

    def _completion_populate_values(self) -> None:
        # FIXME: this needs to be a proper dispatch system
        all_commands = [
            'on', 'off', 'power', '?power', 'mute', 'unmute',
            'hdmi', 'composite', 'scart',
            'vol', 'volume', 'get-vol', 'get-volume', '?vol', '?volume',
            'read', 'read-text', 'write', 'write-text', 'send-text',
            'app', 'apps', '?apps', 'list-apps',
            'list-inputs', '?inputs',
            'key', ':keys',
            ':keypad',
            'danger-reboot',
            ':write', ':default', ':encrypt-setup', ':encrypt-fetch', ':about', ':playing', ':query',
            'help', '?help', ':help',  # skip '?'
        ] + [':'+q for q in dir(self.remote) if q.startswith('query_')]
        # If changing this from sorted, check completion logic.
        self._top_completions = sorted(all_commands)

        key_commands = self.remote.known_keys()
        self._key_completions = sorted(key_commands)

        app_cache = self.remote.config.app_list_file
        if app_cache.exists() and (time.time() - app_cache.stat().st_mtime) < self.remote.config.max_age_app_cache:
            app_names = json.load(app_cache.open())
        else:
            app_names = self.remote.list_apps()
            json.dump(app_names, app_cache.open('w'), indent=1, sort_keys=True)
        self._app_completions = sorted(app_names)

        # The MapSubCommands third item in the tuple is to let us walk down so a third level
        # could be completed by looking in that, instead of self._rl_contexts.
        self._rl_contexts = {
            'key': RLContext('key', True, True, {}),
            'app': RLContext('app', True, False, {})
        }

    def one(self, command: str) -> None:
        remote = self.remote
        if command in self._command_typos:
            print(f'tv: typo fixup: {command!r} -> {self._command_typos[command]!r}', file=sys.stderr)
            command = self._command_typos[command]
        if command == 'on':
            remote.power = True
            return
        elif command == 'off':
            remote.power = False
            return
        elif command in ('power', '?power'):
            print(remote.power)
            return
        elif command == 'mute':
            remote.mute = True
            return
        elif command == 'unmute':
            remote.mute = False
            return
        elif command in ('hdmi', 'composite', 'scart'):
            try:
                port = str(int(self.next(command)))
            except BadInput as e:
                raise BadInput(f'command {command} needs a port (1..4)') from e
            # The actual limit might happen to be 4, but if we want to
            # _enforce_ then don't hard-code;
            # remote.send('avContent', 'getContentCount', {'source': 'extInput:hdmi'})
            # _should_ give us r['result'][0]['count']; I don't want an extra
            # RPC call for static data, so instead punt on enforcing this until
            # such time as we suck it up and build a capabilities cache in XDG
            # storage.
            remote.set_external_input(command, port)
            return
        elif command in ('vol', 'volume'):
            self.volume(self.next(command), True)
            return
        elif command in ('get-vol', 'get-volume', '?vol', '?volume'):
            pretty_print_json(remote.volume)
            return
        elif command in ('read', 'read-text'):
            print(remote.text)
            return
        elif command in ('write', 'write-text', 'send-text'):
            remote.text = self.next(command)
            return
        elif command == 'app':
            remote.launch_app(self.next(command))
            return

        elif command in ('apps', '?apps', 'list-apps'):
            for app in sorted(remote.list_apps()):
                print(f' • {app}')
            return
        elif command in ('list-inputs', '?inputs'):
            maxlen_title, maxlen_label = 1, 1
            for inp in remote.list_inputs():
                tl, ll = len(inp['title']), len(inp['label'])
                if tl > maxlen_title:
                    maxlen_title = tl
                if ll > maxlen_label:
                    maxlen_label = ll
            spec = '{title:<%d}  {label:<%d}  {uri}' % (maxlen_title, maxlen_label)
            for inp in remote.list_inputs():
                print(spec.format(**inp))
            return

        elif command == 'key':
            try:
                keycode = self.next('keycode')
            except BadInput as e:
                if self.repl:
                    raise SubRepl(command) from e
                else:
                    raise
            #
            pause = False
            if keycode != '[':
                remote.key(keycode)
                return
            while keycode != ']':
                try:
                    keycode = self.commands.pop(0)
                    if keycode == ']':
                        break
                except IndexError:
                    return
                if pause:
                    time.sleep(0.25)
                remote.key(keycode)
                pause = True
            return
        elif command == ':keys':
            keylist = remote.known_keys()
            prev = None
            sep = ''
            for k in keylist:
                if prev is not None:
                    if k[0] != prev:
                        sep = '\n'
                    else:
                        sep = ' '
                prev = k[0]
                print(f'{sep}{k}', end='')
            print()
            return
        elif command == ':keypad':
            self.keypad_mode()
            return

        elif command == 'danger-reboot':
            remote.reboot()
            return

        # Our own house-keeping
        elif command == ':write':
            self.remote.config.persist_current(self.next(command))
            return
        elif command == ':default':
            self.remote.config.set_default_tv(self.next(command))
            return
        elif command == ':encrypt-setup':
            self.remote.setup_encryption()
            return
        elif command == ':encrypt-fetch':
            self.remote.setup_encryption(force_fetch=True)
            return

        # Keep :foo for internals and debug
        elif command == ':about':
            remote.query_interface_information()
            return
        elif command == ':playing':
            remote.query_playing_content_info()
            return
        elif command.startswith(':query_') and hasattr(remote, command[1:]):
            getattr(remote, command[1:])()
            return
        elif command == ':query':
            known = [x for x in dir(remote) if x.startswith('query_')]
            for cmd in sorted(known):
                print(':', cmd, sep='')
            return

        elif command in ('help', '?help', ':help', '?'):
            print('''tv: <one or more commands>
 on          off             ?power
 mute        unmute
 vol +n      vol -n          vol NN      ?vol
 hdmi N      composite N     scart N
(read-text   write-text TXT) -- BROKEN
 key KEY     key [ KEY KEY KEY ... ]
 list-inputs
 list-apps       - list installed applications
 app NAME        - launch app NAME
 danger-reboot   - reboots the TV
 :about          - basic information about the TV
 :playing        - current input source
 :query          - list various :query_* debug commands
 :write TVNAME   - write current config as TVNAME and set as default
 :default TVNAME - switch default TV to TVNAME (must exist)
 :encrypt-setup  - immediately setup encryption
 :encrypt-fetch  - force-fetch current TV public key
 :keys           - return list of known remote control keys for 'key' command
 :keypad         - enter a mode where we take arrow keys (&hjkl) to navigate
If the first keycode is left-square bracket, params up until ] are all keys.
''', end='')
            return

        try:
            self.volume(command, False)
            return
        except VolumeSpecParseError:
            pass

        raise BadInput(f'unknown command {command!r}')

    def loop(self) -> None:
        is_subsequent = False
        while self.commands:
            if is_subsequent:
                time.sleep(0.5)
            else:
                is_subsequent = True
            self.one(self.next('').lower())

    def cli(self) -> None:
        self.repl = True
        self._completion_init()
        readline.parse_and_bind('tab: complete')
        if self.remote.config.readline_config.exists():
            readline.read_init_file(self.remote.config.readline_config)
        if hasattr(readline, 'read_history_file'):
            if self.remote.config.readline_history.exists():
                readline.read_history_file(self.remote.config.readline_history)

        self.cli_body_top()

        if hasattr(readline, 'write_history_file'):
            readline.write_history_file(self.remote.config.readline_history)

    # The completion system is a bit hairy.  It swallows exceptions, and
    # because we're in the middle of an input line we can't print there and
    # then.  So we take a two-pronged approach, with far too much logic which
    # an app shouldn't need to worry itself with (hint: a good completion
    # system would provide a diagnostic interface!):
    # 1. We import traceback and manually show exceptions ourselves, which
    #    matters with the slightly baroque calling conventions
    # 2. If verbose >= 3 then we claim the first line of the display and print
    #    diagnostic text up there.  This relies upon the common non-ANSI escape
    #    sequences to push and pop cursor position.

    def complete_debug(self, msg: str) -> None:
        if self.options.verbose < 3:
            return
        MAX = 70
        if len(msg) > MAX:
            msg = '«' + msg[-(MAX-1):]
        bookend = f'\033[41;36m *** \033[m'
        buf = msg + ' ' * (MAX - len(msg))
        print(f'\033[s\033[1;1H{bookend}\033[1;35m{buf}\033[m{bookend}\033[u', end='', flush=True)

    def cdbg(self, append: typing.Optional[str]) -> None:
        if append is None:
            self._debug_completion_buf = ''
            return
        self._debug_completion_buf += ' ' + append
        self.complete_debug(self._debug_completion_buf)

    def push_rl_context(self, name: str) -> None:
        if hasattr(self, '_rl_context_current'):
            self._completion_context_stack.append(self._rl_context_current)
        self._rl_context_current = name
        self._command_set = f'_{name}_completions'

    def pop_rl_context(self) -> None:
        self._rl_context_current = self._completion_context_stack.pop()
        self._command_set = f'_{self._rl_context_current}_completions'

    def _complete_commands(self, text: str, state: int) -> str:
        # readline swallows exceptions!
        try:
            return self._complete_commands_r(text, state)
        except Exception as e:
            print(f'\noops: {e!r} inside completion', file=sys.stderr)
            traceback.print_exc(file=sys.stdout)

    def _complete_commands_r(self, text: str, state: int) -> str:
        self.cdbg(f'completion: {text!r} [{state!r}]')
        ltext = text.lower()
        if ltext and ltext[0] == "'":
            ltext = ltext[1:]
        if self._complete_previous_ctx != self._rl_context_current:
            # We have switched commands, the cache is bad.
            # Especially for the empty string case.
            self._complete_previous = None
            self._complete_cache_prev = None
            self._complete_previous_ctx = self._rl_context_current
        if self._complete_previous is not None and ltext == self._complete_previous:
            self.cdbg('match-prev')
            if self._complete_cache_prev is None:
                self.cdbg('none-avail')
                return None
            self.cdbg('cached')
            if state >= len(self._complete_cache_prev):
                self.cdbg('off-end')
                return None
            result = self._complete_cache_prev[state]
            return shlex.quote(result) if ' ' in result else result
        elif self._complete_previous is not None and ltext.startswith(self._complete_previous):
            self.cdbg('substr')
            considered = self._complete_cache_prev
        else:
            self.cdbg('reset-cand')
            considered = getattr(self, self._command_set)
        self._complete_previous, self._complete_cache_prev = None, None
        # This list is pre-sorted so that state consistently indexes it; since
        # we're caching it, that should be fine.
        avail = [c for c in considered if c.lower().startswith(ltext)]
        return_avail = [shlex.quote(c) if ' ' in c else c for c in avail]
        self._complete_previous = ltext
        if not avail:
            self.cdbg(f'none-found-({len(considered)})')
            return None
        self._complete_cache_prev = avail
        try:
            self.cdbg(f'matched-in-{len(avail)}')
            return return_avail[state]
        except IndexError:
            self.cdbg('FIN')
            return None
        self.cdbg('fell-off-end')

    def use_completer(self, name: str, push_ctx: str, text: str, state: int) -> str:
        if self.options.verbose >= 4:
            print(f'use_completer {name!r} in state {state}', file=sys.stderr, flush=True)
        self._prior_completer = getattr(self, name)
        self._prior_push_ctx = push_ctx
        return getattr(self, name)(text, state)

    def _rl_completer(self, text: str, state: int) -> str:
        if state != 0:
            # We're iterating to get subsequent words, re-use the same completer.
            if self._prior_completer is not None:
                if self._prior_push_ctx is None:
                    return self._prior_completer(text, state)
                else:
                    try:
                        self.push_rl_context(self._prior_push_ctx)
                        return self._prior_completer(text, state)
                    finally:
                        self.pop_rl_context()
        self._prior_completer = None

        self.cdbg(None)
        # We have text which is the current word, but we don't know the word number.
        # In theory, text == line[begin:end] after these queries:
        line = readline.get_line_buffer()
        begin = readline.get_begidx()
        end = readline.get_endidx()
        prior_words = shlex.split(line[:begin])
        self.cdbg(f'RLC {line!r} [{begin}, {end}] {prior_words!r}')
        if not prior_words:
            return self.use_completer('_complete_commands', None, text, state)
        pushed = False
        push_candidate = None
        ctx_tree = self._rl_contexts
        prior_count = len(prior_words)
        last_index = prior_count - 1
        word_index = -1
        ctx = None
        while word_index + 1 <= last_index:
            word_index += 1
            word = prior_words[word_index]
            if word in ctx_tree:
                ctx = ctx_tree[word]
                if ctx.IsCommandSet:
                    if word_index == last_index:
                        # common case
                        push_candidate = ctx.Name
                        break
                    if prior_words[word_index+1] == '[':
                        # key [ foo bar baz ] cmd2
                        # here: word_index == 0, we know there's one more
                        word_index += 1
                        ended = False
                        while word_index + 1 <= last_index:
                            word_index += 1
                            if prior_words[word_index] == ']':
                                ended = True
                                break
                        if not ended:
                            push_candidate = ctx.Name
                            break
                if not ctx.Swallow:
                    ctx_tree = ctx
            # else not in ctx_tree, so it's not taking params, so stay in the current state.
        try:
            if push_candidate is not None:
                self.push_rl_context(push_candidate)
                pushed = True
                return self.use_completer('_complete_commands', push_candidate, text, state)
            else:
                return self.use_completer('_complete_commands', push_candidate, text, state)
        finally:
            if pushed:
                self.pop_rl_context()
        return None

    def cli_body_top(self):
        self.push_rl_context('top')
        readline.set_completer(self._rl_completer)
        # We mostly don't want : or ? in there because we use them as part of
        # command-names; for app names, the quote is part of the completion.
        readline.set_completer_delims(' \t\n')
        # Python default completer delims:
        #   ' \t\n`~!@#$%^&*()-=+[{]}\\|;:\'",<>/?'
        while True:
            try:
                if self.options.verbose >= 4:
                    print(f'ctx={self._rl_context_current!r} cmdset={self._command_set!r} stack={self._completion_context_stack!r} prev={self._complete_previous!r}', file=sys.stderr, flush=True)
                cmd = input('tv> ')
            except EOFError:
                print()
                return
            except KeyboardInterrupt as e:
                print()
                raise Exit(f'killed by {e!r}') from e
            try:
                cmd = cmd.strip()
                if cmd.startswith('#'):
                    continue
                self.commands = shlex.split(cmd)
                self.loop()
            except BadInput as e:
                print('tv:', e, file=sys.stderr)
            except SubRepl as e:
                handler = 'cli_body_' + str(e)
                if hasattr(self, handler):
                    hold = readline.get_completer()
                    ctx_cmds = f'_{str(e)}_completions'
                    pushed = False
                    if hasattr(self, ctx_cmds):
                        self.push_rl_context(str(e))
                        pushed = True
                    getattr(self, handler)()
                    readline.set_completer(hold)
                    if pushed:
                        self.pop_rl_context()
                else:
                    raise Error(f'unknown SubRepl {e}, coding bug here') from e

    def cli_body_key(self):
        # Do we need a different history file, or prefix?
        # I think not; it hasn't happened yet, but I suspect a common pattern
        # will be to enter a key name at the top level, fail, type 'key', then
        # up-arrow twice.
        while True:
            try:
                cmd = input('tv key> ')
            except EOFError:
                print()
                return
            try:
                self.commands = ['key', '['] + shlex.split(cmd) + [']']
                self.loop()
            except BadInput as e:
                print('tv key:', e, file=sys.stderr)

    # Rip this straight from my vlc-control project:
    def curses_pad_for_text(self, text: str):
        if not text:
            return (None, 0, 0)
        lines = text.split('\n')
        if not lines[-1]:
            lines.pop()
        ysize = len(lines) + 2
        xsize = len(max(lines, key=len)) + 2
        pad = curses.newpad(ysize, xsize)
        pad.box()
        for y, l in enumerate(lines):
            pad.addstr(y+1, 1, l)
        return (pad, ysize, xsize)

    def keypad_mode(self):
        if not sys.stdout.isatty():
            raise BadInput('need stdout to be a tty for :keypad mode')

        def quit():
            raise EOFError('Esc')

        screen = curses.initscr()
        pad, pad_max_y, pad_max_x = self.curses_pad_for_text('''Keypad mode:
 Arrow keys and vi hjkl to move.
 Space/Enter to confirm.
 Digits to send digit keys.
 < and > to Rewind and Forward.
 Colors with capital initial: Yellow Blue Red Green
 Esc or q to quit.''')
        screen.refresh()
        pad.refresh( 0,0, 1,1, 1+pad_max_y,1+pad_max_x )

        status_coords = (1+pad_max_y, 3)
        screen.move(*status_coords)
        screen.deleteln()

        try:
            prior_cursor = curses.curs_set(0)
            curses.noecho()
            curses.cbreak()
            screen.keypad(True)
            actions = {
                'q': quit,
                '\033': quit,
                'KEY_BREAK': quit,
                'h': 'Left',
                'j': 'Down',
                'k': 'Up',
                'l': 'Right',
                'KEY_LEFT': 'Left',
                'KEY_DOWN': 'Down',
                'KEY_UP': 'Up',
                'KEY_RIGHT': 'Right',
                ' ': 'Confirm',
                'KEY_ENTER': 'Confirm',
                '\n': 'Confirm',
                '0': 'Num0',
                '1': 'Num1',
                '2': 'Num2',
                '3': 'Num3',
                '4': 'Num4',
                '5': 'Num5',
                '6': 'Num6',
                '7': 'Num7',
                '8': 'Num8',
                '9': 'Num9',
                '<': 'Rewind',
                '>': 'Forward',
                'Y': 'Yellow',
                'B': 'Blue',
                'R': 'Red',
                'G': 'Green',
            }
            while True:
                c = screen.getkey()
                screen.deleteln()
                screen.addstr(repr(c))
                screen.move(*status_coords)
                if c in actions:
                    if callable(actions[c]):
                        actions[c]()
                    else:
                        self.remote.key(actions[c])
                else:
                    curses.beep()
        except EOFError:
            pass
        finally:
            screen.keypad(False)
            curses.nocbreak()
            curses.echo()
            curses.curs_set(prior_cursor)
            curses.endwin()


if sys.stdout.isatty():
    _pp_lexer = pygments.lexers.JsonLexer()
    _pp_formatter = pygments.formatters.TerminalFormatter()

    def pretty_print_json(data, stream=None) -> None:
        if stream is None:
            stream = sys.stdout
        laid_out = json.dumps(data, sort_keys=True, indent=2)
        print(pygments.highlight(laid_out, _pp_lexer, _pp_formatter), file=stream)
else:
    def pretty_print_json(data, stream=None) -> None:
        if stream is None:
            stream = sys.stdout
        print(json.dumps(data, sort_keys=True, indent=2), file=stream)


def _setup_cli_parser() -> argparse.ArgumentParser:
    parser = argparse.ArgumentParser(
        description=__doc__,
        formatter_class=argparse.RawDescriptionHelpFormatter)
    parser.add_argument('-t', '--tv',
                        type=str, default=_DEFAULT_TV,
                        help='Override configuration name for TV [%(default)s]')
    parser.add_argument('-H', '--host',
                        type=str, default='',
                        help='Override TV host/IP [%(default)s]')
    parser.add_argument('--pin',
                        type=str, default='',
                        help='override PIN from config')
    parser.add_argument('-v', '--verbose',
                        action='count', default=0,
                        help='Be more verbose')
    parser.add_argument('rest', nargs='*', metavar='Command',
                        help='TV commands to issue (try :help)')
    return parser


def _main(args: typing.List[str], argv0: str) -> int:
    parser = _setup_cli_parser()
    options = parser.parse_args(args=args)

    config = Config(options)
    remote = Remote(config)

    commander = Commander(remote, options.rest)
    if options.rest:
        commander.loop()
    else:
        commander.cli()
    return 0


if __name__ == '__main__':
    argv0 = pathlib.Path(sys.argv[0]).name
    if argv0.endswith('.py'):
        argv0 = argv0[:-3]
    tracer = None

    def _start(): return _main(sys.argv[1:], argv0=argv0)
    start = _start
    rv = 0
    if os.environ.get('TRACE_' + argv0.upper(), None):
        ignore = [sys.prefix, sys.exec_prefix]
        if 'PYENV_ROOT' in os.environ:
            ignore.append(os.environ['PYENV_ROOT'])
        import trace
        tracer = trace.Trace(
            ignoredirs=ignore,
            count=0,  # skip .cover generation
        )

        def start(): return tracer.run('_start()')
    try:
        rv = start()
    except Exit as e:
        for arg in e.args:
            print('{}: {}'.format(argv0, arg), file=sys.stderr)
        sys.exit(1)
    finally:
        if tracer:
            tracer.results().write_results()
    sys.exit(rv)

# Debugging:
# import pathlib; __name__, __file__ = 'debug-tv', 'tv'; exec(pathlib.Path('~/tools/site/common/tv').expanduser().read_text())
if __name__ == 'debug-tv':
    parser = _setup_cli_parser()
    options = parser.parse_args(args=[':help'])
    config = Config(options)
    remote = Remote(config)

# vim: set ft=python sw=4 expandtab :
