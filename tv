#!/usr/bin/env python3

"""
tv: control living-room TV

The Sony TV has a JSON REST-ish RPC interface.

Beware that digits on the remote do not enter ASCII digits but some other
unicode digits.

Beware that encryption keys are not very securely managed, but I think it's
about appropriate for use as a TV remote, since I don't want to have to enter a
password to talk to the TV.  So we have a `changeme` level non-secret used as
a tiny obfuscation layer for local storage.  Since we're already storing the PIN
to talk to the TV in clear-text on disk, there's no worse vulnerability here.
"""

__author__ = 'phil@pennock-tech.com (Phil Pennock)'

import argparse
import atexit
import base64
import collections
from dataclasses import dataclass
import html
import json
import os
import pathlib
import re
import readline
import secrets
import shlex
import sys
import time
import typing

# TV can encrypt text strings, which we want for sending/reading passwords in app prompts
import cryptography.hazmat.backends
import cryptography.hazmat.primitives
import cryptography.hazmat.primitives.padding
# import cryptography.hazmat.primitives.asymmetric.rsa
# Sane HTTP
import requests

if sys.stdout.isatty():
    import pygments
    import pygments.lexers
    import pygments.formatters

if sys.version_info < (3, 6):
    raise Exception('Need at least Python 3.6 for this tool')
    # pathlib, f-strings

SCRIPT_DIR = pathlib.Path(__file__).absolute().parent

# FIXME: this is not fully XDG-compliant
_APP_NAME = pathlib.Path('tv')
_HOME_DIR = _APP_NAME.home()


def _xdg_dir(varname: str, home_rel_default: typing.Sequence[str]) -> pathlib.Path:
    ps = os.getenv(varname, None)
    if ps is None:
        p = _HOME_DIR
        for n in home_rel_default:
            p = p / n
    else:
        p = pathlib.Path(ps)
    return p / _APP_NAME


_CONFIG_DIR = _xdg_dir('XDG_CONFIG_HOME', ('.config',))      # read files: default.pin and default.hostname
_CACHE_DIR = _xdg_dir('XDG_CACHE_HOME', ('.cache',))         # keep a copy of the TV's public key for encryption
_DATA_DIR = _xdg_dir('XDG_DATA_HOME', ('.local', 'share',))  # keep our local private/public keys for encryption
_DEFAULT_TV = 'default'

DEF_USERAGENT = 'tv/0.2 (Phil Pennock)'
# This exists just for local disk and might as well be the empty string, but I
# don't want to fight APIs any more, so this is one generated password which
# I'm leaving in source, on the basis that it's like bouncycastle's "changeme"
# string: a password that's not a password, just a known serialization
# constant:
PRIVATE_KEY_PASSWORD = b'Wh#2#*4zbWBH0_o4x,Ad'


class Error(Exception):
    """Base class for exceptions from tv."""
    pass


class VolumeSpecParseError(Error):
    """Unparseable volume specification."""
    pass


class Exit(Exception):
    """Base class for exceptions which exit without a stack trace."""
    pass


class BadInput(Exit):
    """Exceptions indicating bad user input."""
    pass


IRCCKeyCode = collections.namedtuple('IRCCKeyCode', ['KeyName', 'Rawcode'])


@dataclass
class WrapCrypto:
    backend: typing.Any = cryptography.hazmat.backends.default_backend()
    DER: typing.Any = cryptography.hazmat.primitives.serialization.Encoding.DER
    PEM: typing.Any = cryptography.hazmat.primitives.serialization.Encoding.PEM
    PKCS1: typing.Any = cryptography.hazmat.primitives.serialization.PublicFormat.PKCS1
    PKCS7: typing.Any = cryptography.hazmat.primitives.padding.PKCS7
    PKCS8: typing.Any = cryptography.hazmat.primitives.serialization.PrivateFormat.PKCS8
    SPKI: typing.Any = cryptography.hazmat.primitives.serialization.PublicFormat.SubjectPublicKeyInfo
    AES: typing.Any = cryptography.hazmat.primitives.ciphers.algorithms.AES
    CBC: typing.Any = cryptography.hazmat.primitives.ciphers.modes.CBC
    PKCS1v15: typing.Any = cryptography.hazmat.primitives.asymmetric.padding.PKCS1v15
    PrivateRaw: typing.Any = cryptography.hazmat.primitives.serialization.PrivateFormat.Raw
    Cipher: typing.Any = cryptography.hazmat.primitives.ciphers.Cipher
    # NoEncryption apparently does not satisfy KeySerializationEncryption
    # I want one fixed serialization type so I can safely load, but
    # cryptography only lets me have access to the mutable curated choice.
    BestAvailableEncryption: typing.Any = cryptography.hazmat.primitives.serialization.BestAvailableEncryption
    want_exponent: int = 65537
    want_keysize: int = 2048
    AES_BLOCKSIZE_BITS: int = 128
    AES_BLOCKSIZE_U8: int = 16


Crypto = WrapCrypto()


class SymKey:
    AES_KEY: typing.Optional[bytes] = None
    AES_IV: typing.Optional[bytes] = None

    def __init__(self):
        if SymKey.AES_KEY is None:
            SymKey.AES_KEY = secrets.token_bytes(Crypto.AES_BLOCKSIZE_U8)
        if SymKey.AES_IV is None:
            SymKey.AES_IV = secrets.token_bytes(Crypto.AES_BLOCKSIZE_U8)
        self.aes_key = SymKey.AES_KEY
        self.aes_iv = SymKey.AES_IV
        SymKey.AES_IV = (int.from_bytes(SymKey.AES_IV, byteorder='big') + 1).to_bytes(Crypto.AES_BLOCKSIZE_U8, byteorder='big')
        self.cipher = Crypto.Cipher(Crypto.AES(self.aes_key), Crypto.CBC(self.aes_iv), backend=Crypto.backend)

    def common_key(self) -> bytes:
        return self.aes_key + b':' + self.aes_iv

    def encKey(self, pubKey: cryptography.hazmat.primitives.asymmetric.rsa.RSAPublicKey) -> str:
        return base64.b64encode(pubKey.encrypt(
            self.common_key(),
            Crypto.PKCS1v15(),
        )).decode('ASCII')

    def encrypt(self, data: str) -> str:
        padder = Crypto.PKCS7(Crypto.AES_BLOCKSIZE_BITS).padder()
        padded = padder.update(data.encode('utf-8'))
        padded += padder.finalize()
        enc = self.cipher.encryptor()
        return base64.b64encode(enc.update(padded) + enc.finalize()).decode('ASCII')

    def decrypt(self, data: str) -> str:
        dec = self.cipher.decryptor()
        padded = dec.update(data) + dec.finalize()
        unpadder = Crypto.PKCS7(Crypto.AES_BLOCKSIZE_BITS).unpadder()
        return (unpadder.update(padded) + unpadder.finalize()).encode('utf-8')


class Config:
    """Our storage system and local RSA key mgmt."""

    PIN_OPTION, PIN_FILEEXT = 'pin', 'pin'
    HOST_OPTION, HOST_FILEEXT = 'host', 'hostname'

    def __init__(self, options: argparse.Namespace) -> None:
        self.options = options
        # .tv is the config name as given, often 'default
        # .real_tv is the actual name, use this to write files
        self.tv = self.options.tv
        self.tv_pin = self.derive_field(Config.PIN_OPTION, Config.PIN_FILEEXT)
        self.tv_host = self.derive_field(Config.HOST_OPTION, Config.HOST_FILEEXT)
        self.using_default = self.tv == _DEFAULT_TV
        if self.using_default:
            self.real_tv = self._find_real_tvname()
        else:
            self.real_tv = self.tv
        self.our_rsakey: typing.Optional[cryptography.hazmat.primitives.asymmetric.rsa.RSAPublicKey] = None
        self.aes_iv: typing.Optional[bytes] = None
        self.aes_key: typing.Optional[bytes] = None

    def derive_field(self, optname: str, base: str) -> str:
        t = getattr(self.options, optname)
        if t:
            return t
        return self.read_config(base)

    def read_config(self, base: str) -> str:
        fn = _CONFIG_DIR / (self.options.tv + '.' + base)
        return fn.read_text().strip()

    def _find_real_tvname(self) -> str:
        default_pin_file = _CONFIG_DIR / (_DEFAULT_TV + '.' + Config.PIN_FILEEXT)
        return default_pin_file.resolve().stem

    @property
    def readline_config(self) -> pathlib.Path:
        return _CONFIG_DIR / 'readline.conf'

    @property
    def tv_keyfile(self) -> pathlib.Path:
        return _CACHE_DIR / (self.real_tv + '.tv.rsa.pub')

    @property
    def tv_ircc_codes_file(self) -> pathlib.Path:
        return _CACHE_DIR / (self.real_tv + '.ircc-codes.json')

    @property
    def readline_history(self) -> pathlib.Path:
        return _CACHE_DIR / (self.real_tv + '.readline.history')

    @property
    def our_public_keyfile(self) -> pathlib.Path:
        return _DATA_DIR / 'our.rsa.pub'

    @property
    def our_private_keyfile(self) -> pathlib.Path:
        return _DATA_DIR / 'our.rsa.private'

    def persist_current(self, new_tvname: str) -> None:
        # A name of '' will write out to current
        write_name = new_tvname if new_tvname else self.real_tv
        forbidden = [os.path.sep, os.path.pathsep]
        if os.path.extsep:
            forbidden += [os.path.extsep]
        if True in [c in write_name for c in forbidden]:
            raise Error(f'bad characters in {write_name!r}')

        # We will write the derived merged values, so can modify an existing TV to a new name.

        if not _CONFIG_DIR.exists():
            _CONFIG_DIR.mkdir(mode=0o700, parents=True)

        if write_name == _DEFAULT_TV:
            write_name = _DEFAULT_TV + '-real'
        pin_file = _CONFIG_DIR / (write_name + '.' + Config.PIN_FILEEXT)
        host_file = _CONFIG_DIR / (write_name + '.' + Config.HOST_FILEEXT)
        # Don't update defaults until both named entries have been written
        for f, content in [(pin_file, self.tv_pin), (host_file, self.tv_host)]:
            if f.exists():
                f.unlink()
            f.touch(mode=0o600, exist_ok=False)
            f.write_text(content + '\n', encoding='utf-8')
        self.set_default_tv(write_name)

    def set_default_tv(self, target_tvname: str) -> None:
        # We have no locking here, so not safe against a concurrent reader.
        # For myself now, I don't currently care.
        default_pin_file = _CONFIG_DIR / (_DEFAULT_TV + '.' + Config.PIN_FILEEXT)
        default_host_file = _CONFIG_DIR / (_DEFAULT_TV + '.' + Config.HOST_FILEEXT)
        pin_file = _CONFIG_DIR / (target_tvname + '.' + Config.PIN_FILEEXT)
        host_file = _CONFIG_DIR / (target_tvname + '.' + Config.HOST_FILEEXT)
        if not pin_file.exists():
            raise BadInput(f"can't repoint default TV to {target_tvname!r}, missing {pin_file.name!r}")
        if not host_file.exists():
            raise BadInput(f"can't repoint default TV to {target_tvname!r}, missing {host_file.name!r}")
        for src, dest in [(default_pin_file, pin_file), (default_host_file, host_file)]:
            if src.exists() and not src.is_symlink():
                src.rename(src.with_suffix('.old' + src.suffix))
            if src.exists() or src.is_symlink():
                src.unlink()
            src.symlink_to(dest.name)

    def load_pubkey_b64(self, b64data: str) -> cryptography.hazmat.primitives.asymmetric.rsa.RSAPublicKey:
        return self.load_pubkey_bin(base64.b64decode(b64data, validate=True))

    def load_pubkey_bin(self, bindata: bytes) -> cryptography.hazmat.primitives.asymmetric.rsa.RSAPublicKey:
        return cryptography.hazmat.primitives.serialization.load_der_public_key(bindata, backend=Crypto.backend)

    def make_rsa_key(self) -> cryptography.hazmat.primitives.asymmetric.rsa.RSAPrivateKey:
        return cryptography.hazmat.primitives.asymmetric.rsa.generate_private_key(
            public_exponent=Crypto.want_exponent,
            key_size=Crypto.want_keysize,
            backend=Crypto.backend)

    def write_file(self, fpath: pathlib.Path, data: bytes) -> None:
        if not fpath.parent.exists():
            fpath.parent.mkdir(0o700)
        if fpath.exists():
            saved = fpath.with_suffix('.old' + fpath.suffix)
            if saved.exists():
                saved.unlink()
            fpath.rename(saved)
        fpath.touch(mode=0o600, exist_ok=False)
        fpath.write_bytes(data)

    def save_our_private_key(self, rsakey: cryptography.hazmat.primitives.asymmetric.rsa.RSAPrivateKey) -> None:
        self.write_file(
            self.our_private_keyfile,
            rsakey.private_bytes(
                encoding=Crypto.PEM,
                format=Crypto.PKCS8,
                encryption_algorithm=Crypto.BestAvailableEncryption(PRIVATE_KEY_PASSWORD)),
        )

    def save_our_public_key(self, rsakey: cryptography.hazmat.primitives.asymmetric.rsa.RSAPrivateKey) -> None:
        # We don't use this ourselves, we do this so that other tooling can look at it if wanted.
        self.write_file(
            self.our_public_keyfile,
            rsakey.public_key().public_bytes(Crypto.PEM, Crypto.PKCS1),
        )

    def setup_thisremote_encryption(self, force_new_remote_key=False) -> None:
        if self.our_private_keyfile.exists() and not force_new_remote_key:
            self.our_rsakey = cryptography.hazmat.primitives.serialization.load_pem_private_key(
                self.our_private_keyfile.read_bytes(),
                password=PRIVATE_KEY_PASSWORD,
                backend=Crypto.backend)
        else:
            self.our_rsakey = self.make_rsa_key()
            self.save_our_public_key(self.our_rsakey)
            self.save_our_private_key(self.our_rsakey)

    def load_ircc_codes(self) -> typing.Dict:
        bare = json.load(open(self.tv_ircc_codes_file))
        typed: typing.Dict[str, IRCCKeyCode] = {}
        for k, p in bare.items():
            typed[k] = IRCCKeyCode(*p)
        return typed

    def save_ircc_codes(self, jdata: typing.Dict) -> None:
        with self.tv_ircc_codes_file.open('w') as wh:
            # sort to make git and diff saner, if we move from cache
            json.dump(jdata, wh, indent=1, sort_keys=True)


class Remote:
    """Talking to the TV via various protocols.

    Most of the stuff is REST API, but anything which is directly emulating a
    remote control is IRCC-IP (InfraRed Compatible Control over Internet Protocol),
    using SOAP XML.
    """

    def __init__(self, config: Config) -> None:
        self.options = config.options
        self.config = config
        self.next_id = 1
        self.addr = config.tv_host
        self.pin = config.tv_pin
        self._tv_pubkey_b64: typing.Optional[str] = None
        self._tv_pubkey_bin: typing.Optional[bytes] = None
        self._ircc_dict: typing.Optional[typing.Dict] = None
        self._setup_requests()

    def verbosity(self, n: int = 1) -> bool:
        return True if self.options.verbose >= n else False

    def verbose(self, message: str, level=1) -> None:
        if self.options.verbose < level:
            return
        print('[remote] '+message, file=sys.stderr, flush=True)

    def _setup_requests(self) -> None:
        self.session = requests.Session()
        self.session.headers['User-Agent'] = DEF_USERAGENT
        self.session.headers['X-Auth-PSK'] = self.pin

    def _send(self, service: str, method: str, params: typing.Dict, *, api_version='1.0'):
        url = f'http://{self.addr}/sony/{service}'
        payload_d = {
            'method': method,
            'version': api_version,
            'id': self.next_id,
            'params': [params] if params else [],
        }
        self.next_id += 1
        if self.verbosity(3):
            print(f'> POST <{url}> ', end='')
            pretty_print_json(payload_d)
        elif self.verbosity(2):
            print(f' >> {service} / {method}')
        r = self.session.post(url, json=payload_d)
        return r

    def send(self, service: str, method: str, params: typing.Dict, **kwargs) -> None:
        r = self._send(service, method, params, **kwargs)
        if self.verbosity():
            pretty_print_json(r.json())

    def query(self, service: str, method: str, params: typing.Dict, **kwargs) -> typing.Dict:
        res = self._send(service, method, params, **kwargs)
        if self.verbosity(3):
            print(f'< {res.status_code} {res.reason}')
            if self.verbosity(4):
                pretty_print_json(dict(res.headers))
            pretty_print_json(res.json())
        return res.json()

    def check_error(self, label: str, result: typing.Dict) -> None:
        if 'error' not in result:
            return
        code, message = result['error'][:2]
        raise Exit(f'failed in {label}: code {code} message: {message}')

    # <https://pro-bravia.sony.net/develop/integrate/rest-api/spec/>
    KNOWN_SERVICES = 'guide appControl audio avContent encryption system videoScreen'.split()

    def _get_power(self) -> str:
        resp = self.query('system', 'getPowerStatus', {})
        return resp['result'][0]['status']

    def _set_power(self, power_state: bool) -> None:
        self.send('system', 'setPowerStatus', {'status': power_state})

    power = property(_get_power, _set_power, None)

    def _set_mute(self, mute_state: bool) -> None:
        self.send('audio', 'setAudioMute', {'status': mute_state})

    mute = property(None, _set_mute, None)

    # this is paired with :playing, query_playing_content_info()
    # might build a map of uris to labels and try to simplify through that, for a better reader?
    def set_external_input(self, kind: str, port: str) -> None:
        uri = f'extInput:{kind}?port={port}'
        self.send('avContent', 'setPlayContent', {'uri': uri})

    def _get_volume(self) -> typing.List[typing.Dict]:
        resp = self.query('audio', 'getVolumeInformation', {})
        return resp['result'][0]

    def _set_volume(self, new_volume: str) -> None:
        # api 1.2 lets us control if the on-screen volume UI should be displayed; stick to 1.0, accept UI defaults
        self.send('audio', 'setAudioVolume', {'target': 'speaker', 'volume': new_volume})

    volume = property(_get_volume, _set_volume, None)

    def reboot(self) -> None:
        self.send('system', 'requestReboot', {})

    def list_apps(self) -> typing.List[str]:
        apps = self.query('appControl', 'getApplicationList', {})
        return [html.unescape(x['title']) for x in apps['result'][0]]

    def launch_app(self, appname: str) -> None:
        needle = appname.lower()
        res = self.query('appControl', 'getApplicationList', {})
        filtered = [app for app in res['result'][0] if html.unescape(app['title']).lower() == needle]
        if not filtered:
            raise BadInput(f'unknown app {appname!r}')
        if len(filtered) > 1:
            applist = ', '.join(map(lambda x: shlex.quote(html.unescape(x['title'])), filtered))
            raise BadInput(f'too many apps found for {appname!r}: {applist}')
        uri = filtered[0]['uri']
        self.send('appControl', 'setActiveApp', {'uri': uri})

    def list_inputs(self) -> typing.List[typing.Dict]:
        inputs = self.query('avContent', 'getCurrentExternalInputsStatus', {}, api_version='1.1')
        return inputs['result'][0]

    # All methods with names starting 'query_' are directly exposed by the
    # Commander as debug commands, specified with a leading colon,
    # thus `tv :query_time` works.

    def query_supported_apis(self) -> None:
        pretty_print_json(self.query('guide', 'getSupportedApiInfo', {'services': Remote.KNOWN_SERVICES}))

    def query_time(self) -> None:
        pretty_print_json(self.query('system', 'getCurrentTime', {}, api_version='1.1'))

    def query_network_settings(self) -> None:
        # We shouldn't need netif per the spec, but we get "Illegal Argument" without it
        pretty_print_json(self.query('system', 'getNetworkSettings', {'netif': ''}))

    def query_interface_information(self) -> None:
        pretty_print_json(self.query('system', 'getInterfaceInformation', {})['result'][0])

    def query_sound_settings(self) -> None:
        # Array, one for each target
        pretty_print_json(self.query('audio', 'getSoundSettings', {'target': ''}, api_version='1.1')['result'][0])

    def query_speaker_settings(self) -> None:
        # Array, one for each target
        pretty_print_json(self.query('audio', 'getSpeakerSettings', {'target': ''})['result'][0])

    def query_playing_content_info(self) -> None:
        pretty_print_json(self.query('avContent', 'getPlayingContentInfo', {})['result'][0])

    def setup_encryption(self, force_fetch=False, tv_only=False, **kwargs) -> None:
        if not tv_only:
            self.config.setup_thisremote_encryption(**kwargs)
        if self.config.tv_keyfile.exists() and not force_fetch:
            self._tv_pubkey_b64 = self.config.tv_keyfile.read_text().strip()
        else:
            kd = self.query('encryption', 'getPublicKey', {})
            self._tv_pubkey_b64 = kd['result'][0]['publicKey']
            if not self._tv_pubkey_b64:
                raise Exit('TV gave us an empty public key')
            if not self.config.tv_keyfile.parent.exists():
                self.config.tv_keyfile.parent.mkdir(0o700)
            self.config.tv_keyfile.write_text(self._tv_pubkey_b64 + '\n')
        self._tv_pubkey_bin = base64.b64decode(self._tv_pubkey_b64, validate=True)

    @property
    def tv_pubkey(self) -> cryptography.hazmat.primitives.asymmetric.rsa.RSAPublicKey:
        if self._tv_pubkey_bin is None:
            self.setup_encryption(tv_only=True)
            if self._tv_pubkey_bin is None:
                raise Error('still no pubkey bin after setting up encryption')
        return self.config.load_pubkey_bin(self._tv_pubkey_bin)

    def get_text_form(self) -> str:
        key = SymKey()
        encKey = key.encKey(self.tv_pubkey)
        res = self.query('appControl', 'getTextForm', {
            'encKey': encKey,
        }, api_version='1.1')
        self.check_error('get_text_form', res)
        encText = res['result'][0]['text']
        return key.decrypt(encText)

    def set_text_form(self, newText: str) -> None:
        key = SymKey()
        res = self.query('appControl', 'setTextForm', {
            'text': key.encrypt(newText),
            'encKey': key.encKey(self.tv_pubkey),
        }, api_version='1.1')
        self.check_error('set_text_form', res)
        if 'result' not in res:
            raise Error('missing result (expected empty but present) in set_text_form response')

    text = property(get_text_form, set_text_form, None)

    def _send_ircc_rawcode(self, rawcode: str) -> None:
        # <https://pro-bravia.sony.net/develop/integrate/ircc-ip/overview/index.html>
        url = f'http://{self.addr}/sony/ircc'
        soap_headers = {
            'Content-Type': 'text/xml; charset=UTF-8',
            'SOAPACTION': '"urn:schemas-sony-com:service:IRCC:1#X_SendIRCC"'
        }
        soap_payload_template = '''<s:Envelope
    xmlns:s="http://schemas.xmlsoap.org/soap/envelope/"
    s:encodingStyle="http://schemas.xmlsoap.org/soap/encoding/">
    <s:Body>
        <u:X_SendIRCC xmlns:u="urn:schemas-sony-com:service:IRCC:1">
            <IRCCCode>{0}</IRCCCode>
        </u:X_SendIRCC>
    </s:Body>
</s:Envelope>
'''
        self.verbose(f'_send_ircc_rawcode: SOAP IRCCCode {rawcode}', level=4)
        r = self.session.post(url,
                              data=soap_payload_template.format(rawcode),
                              headers=soap_headers)
        r.raise_for_status()
        return r

    def _setup_ircc(self):
        if self._ircc_dict is not None:
            return
        try:
            self._ircc_dict = self.config.load_ircc_codes()
            return
        except FileNotFoundError:
            pass
        r = self.query('system', 'getRemoteControllerInfo', {})
        self.check_error('getRemoteControllerInfo', r)
        # Ideally we'd have a handy case-insensitive dict, so we could store
        # preserving the capitalization but not worry for command entry.
        #
        # result[0] is deprecated; result[1] is list of objs, each with 'name' and 'value' keys
        codes = {}
        for pair in r['result'][1]:
            kp = pair['name']
            k = kp.lower()
            v = pair['value']
            if k in codes:
                self.verbose(f'duplicate IRCC code for {kp!r}: had: {codes[k]} also: {v}')
                continue
            codes[k] = IRCCKeyCode(kp, v)
        self.config.save_ircc_codes(codes)
        self._ircc_dict = codes

    def key(self, keyname: str) -> None:
        self._setup_ircc()

        # Why Num 0-9,11,12 ?  Where's the love for 10?
        if len(keyname) == 1 and keyname.isdigit() or keyname in ('Num11', 'Num12',):
            keyname = 'Num' + keyname
        lk = keyname.lower()

        if lk not in self._ircc_dict:
            raise BadInput(f'unknown keycode {keyname!r}')
        self._send_ircc_rawcode(self._ircc_dict[lk].Rawcode)

    def known_keys(self) -> typing.List[str]:
        self._setup_ircc()
        keylist = [None] * len(self._ircc_dict)
        for i, k in enumerate(self._ircc_dict.keys()):
            keylist[i] = self._ircc_dict[k].KeyName
        return sorted(keylist)


class Commander:
    """Command interpreter."""

    def __init__(self, remote: Remote, commands: typing.List[str]) -> None:
        self.options = remote.options
        self.remote = remote
        self.commands = commands
        self.vol_matcher = re.compile(r'^([+-])(\d+)\Z')

    def next(self, previous: str) -> str:
        try:
            return self.commands.pop(0)
        except IndexError:
            raise BadInput(f'parameter needed for command {previous!r}')

    def volume(self, spec: str, allow_absolute: bool) -> None:
        m = self.vol_matcher.match(spec)
        if m:
            if int(m.group(2)) > 10:
                raise BadInput('can only raise/lower by up to ±10')
            self.remote.volume = spec
            return

        if not allow_absolute:
            raise VolumeSpecParseError(f'unhandled volume spec {spec!r}')
        ivol = int(spec)
        if ivol > 100:
            raise BadInput('can only set volume to absolute 0..100')
        self.remote.volume = str(ivol)

    _command_typos = {
        'hmdi': 'hdmi',
    }

    def one(self, command: str) -> None:
        remote = self.remote
        if command in self._command_typos:
            print(f'tv: typo fixup: {command!r} -> {self._command_typos[command]!r}', file=sys.stderr)
            command = self._command_typos[command]
        if command == 'on':
            remote.power = True
            return
        elif command == 'off':
            remote.power = False
            return
        elif command in ('power', '?power'):
            print(remote.power)
            return
        elif command == 'mute':
            remote.mute = True
            return
        elif command == 'unmute':
            remote.mute = False
            return
        elif command in ('hdmi', 'composite', 'scart'):
            try:
                port = str(int(self.next(command)))
            except BadInput:
                raise BadInput(f'command {command} needs a port (1..4)')
            # The actual limit might happen to be 4, but if we want to
            # _enforce_ then don't hard-code;
            # remote.send('avContent', 'getContentCount', {'source': 'extInput:hdmi'})
            # _should_ give us r['result'][0]['count']; I don't want an extra
            # RPC call for static data, so instead punt on enforcing this until
            # such time as we suck it up and build a capabilities cache in XDG
            # storage.
            remote.set_external_input(command, port)
            return
        elif command in ('vol', 'volume'):
            self.volume(self.next(command), True)
            return
        elif command in ('get-vol', 'get-volume', '?vol', '?volume'):
            pretty_print_json(remote.volume)
            return
        elif command in ('read', 'read-text'):
            print(remote.text)
            return
        elif command in ('write', 'write-text', 'send-text'):
            remote.text = self.next(command)
            return
        elif command == 'app':
            remote.launch_app(self.next(command))
            return

        elif command in ('apps', '?apps', 'list-apps'):
            for app in sorted(remote.list_apps()):
                print(f' • {app}')
            return
        elif command in ('list-inputs', '?inputs'):
            maxlen_title, maxlen_label = 1, 1
            for inp in remote.list_inputs():
                tl, ll = len(inp['title']), len(inp['label'])
                if tl > maxlen_title:
                    maxlen_title = tl
                if ll > maxlen_label:
                    maxlen_label = ll
            spec = '{title:<%d}  {label:<%d}  {uri}' % (maxlen_title, maxlen_label)
            for inp in remote.list_inputs():
                print(spec.format(**inp))
            return

        elif command == 'key':
            keycode = self.next('keycode')
            pause = False
            if keycode != '[':
                remote.key(keycode)
                return
            while keycode != ']':
                try:
                    keycode = self.commands.pop(0)
                    if keycode == ']':
                        break
                except IndexError:
                    return
                if pause:
                    time.sleep(0.25)
                remote.key(keycode)
                pause = True
            return
        elif command == ':keys':
            keylist = remote.known_keys()
            prev = None
            sep = ''
            for k in keylist:
                if prev is not None:
                    if k[0] != prev:
                        sep = '\n'
                    else:
                        sep = ' '
                prev = k[0]
                print(f'{sep}{k}', end='')
            print()
            return

        elif command == 'danger-reboot':
            remote.reboot()
            return

        # Our own house-keeping
        elif command == ':write':
            self.remote.config.persist_current(self.next(command))
            return
        elif command == ':default':
            self.remote.config.set_default_tv(self.next(command))
            return
        elif command == ':encrypt-setup':
            self.remote.setup_encryption()
            return
        elif command == ':encrypt-fetch':
            self.remote.setup_encryption(force_fetch=True)
            return

        # Keep :foo for internals and debug
        elif command == ':about':
            remote.query_interface_information()
            return
        elif command == ':playing':
            remote.query_playing_content_info()
            return
        elif command.startswith(':query_') and hasattr(remote, command[1:]):
            getattr(remote, command[1:])()
            return
        elif command == ':query':
            known = [x for x in dir(remote) if x.startswith('query_')]
            for cmd in sorted(known):
                print(':', cmd, sep='')
            return

        elif command in ('help', '?help', ':help'):
            print('''tv: <one or more commands>
 on          off             ?power
 mute        unmute
 vol +n      vol -n          vol NN      ?vol
 hdmi N      composite N     scart N
(read-text   write-text TXT) -- BROKEN
 key KEY     key [ KEY KEY KEY ... ]
 list-inputs
 list-apps       - list installed applications
 app NAME        - launch app NAME
 danger-reboot   - reboots the TV
 :about          - basic information about the TV
 :playing        - current input source
 :query          - list various :query_* debug commands
 :write TVNAME   - write current config as TVNAME and set as default
 :default TVNAME - switch default TV to TVNAME (must exist)
 :encrypt-setup  - immediately setup encryption
 :encrypt-fetch  - force-fetch current TV public key
 :keys           - return list of known remote control keys for 'key' command
If the first keycode is left-square bracket, params up until ] are all keys.
''', end='')
            return

        try:
            self.volume(command, False)
            return
        except VolumeSpecParseError:
            pass

        raise BadInput(f'unknown command {command!r}')

    def loop(self) -> None:
        is_subsequent = False
        while self.commands:
            if is_subsequent:
                time.sleep(0.5)
            else:
                is_subsequent = True
            self.one(self.next('').lower())

    def cli(self) -> None:
        if self.remote.config.readline_config.exists():
            readline.read_init_file(self.remote.config.readline_config)
        if hasattr(readline, 'read_history_file'):
            if self.remote.config.readline_history.exists():
                readline.read_history_file(self.remote.config.readline_history)
            atexit.register(readline.write_history_file, self.remote.config.readline_history)

        while True:
            try:
                cmd = input('tv> ')
            except EOFError:
                print()
                return
            try:
                self.commands = cmd.split()
                self.loop()
            except BadInput as e:
                print('tv:', e, file=sys.stderr)


if sys.stdout.isatty():
    _pp_lexer = pygments.lexers.JsonLexer()
    _pp_formatter = pygments.formatters.TerminalFormatter()

    def pretty_print_json(data, stream=None) -> None:
        if stream is None:
            stream = sys.stdout
        laid_out = json.dumps(data, sort_keys=True, indent=2)
        print(pygments.highlight(laid_out, _pp_lexer, _pp_formatter), file=stream)
else:
    def pretty_print_json(data, stream=None) -> None:
        if stream is None:
            stream = sys.stdout
        print(json.dumps(data, sort_keys=True, indent=2), file=stream)


def _setup_cli_parser() -> argparse.ArgumentParser:
    parser = argparse.ArgumentParser(
        description=__doc__,
        formatter_class=argparse.RawDescriptionHelpFormatter)
    parser.add_argument('-t', '--tv',
                        type=str, default=_DEFAULT_TV,
                        help='Override configuration name for TV [%(default)s]')
    parser.add_argument('-H', '--host',
                        type=str, default='',
                        help='Override TV host/IP [%(default)s]')
    parser.add_argument('--pin',
                        type=str, default='',
                        help='override PIN from config')
    parser.add_argument('-v', '--verbose',
                        action='count', default=0,
                        help='Be more verbose')
    parser.add_argument('rest', nargs='*', metavar='Command',
                        help='TV commands to issue (try :help)')
    return parser


def _main(args: typing.List[str], argv0: str) -> int:
    parser = _setup_cli_parser()
    options = parser.parse_args(args=args)

    config = Config(options)
    remote = Remote(config)

    commander = Commander(remote, options.rest)
    if options.rest:
        commander.loop()
    else:
        commander.cli()
    return 0


if __name__ == '__main__':
    argv0 = pathlib.Path(sys.argv[0]).name
    if argv0.endswith('.py'):
        argv0 = argv0[:-3]
    tracer = None

    def _start(): return _main(sys.argv[1:], argv0=argv0)
    start = _start
    rv = 0
    if os.environ.get('TRACE_' + argv0.upper(), None):
        ignore = [sys.prefix, sys.exec_prefix]
        if 'PYENV_ROOT' in os.environ:
            ignore.append(os.environ['PYENV_ROOT'])
        import trace
        tracer = trace.Trace(
            ignoredirs=ignore,
            count=0,  # skip .cover generation
        )

        def start(): return tracer.run('_start()')
    try:
        rv = start()
    except Exit as e:
        for arg in e.args:
            print('{}: {}'.format(argv0, arg), file=sys.stderr)
        sys.exit(1)
    finally:
        if tracer:
            tracer.results().write_results()
    sys.exit(rv)

# Debugging:
# import pathlib; __name__, __file__ = 'debug-tv', 'tv'; exec(pathlib.Path('~/tools/site/common/tv').expanduser().read_text())
if __name__ == 'debug-tv':
    parser = _setup_cli_parser()
    options = parser.parse_args(args=[':help'])
    config = Config(options)
    remote = Remote(config)

# vim: set ft=python sw=4 expandtab :
