#!/usr/bin/env python3

"""
tv: control living-room TV

The Sony TV has a JSON REST-ish RPC interface.

Beware that digits on the remote do not enter ASCII digits but some other
unicode digits.

Beware that encryption keys are not very securely managed, but I think it's
about appropriate for use as a TV remote, since I don't want to have to enter a
password to talk to the TV.  So we have a `changeme` level non-secret used as
a tiny obfuscation layer for local storage.  Since we're already storing the PIN
to talk to the TV in clear-text on disk, there's no worse vulnerability here.
"""

__author__ = 'phil@pennock-tech.com (Phil Pennock)'

import argparse
import base64
from dataclasses import dataclass
import html
import os
import pathlib
import re
import shlex
import sys
import time
import typing

# TV can encrypt text strings, which we want for sending/reading passwords in app prompts
import cryptography.hazmat.backends
import cryptography.hazmat.primitives.asymmetric.rsa
# Sane HTTP
import requests

try:
    import pdpgeneric
    def pretty_print_json(data) -> None:
        print(pdpgeneric.colored_json(data))
except ImportError:
    import json
    def pretty_print_json(data) -> None:
        json.dumps(data, sort_keys=True, indent=2)

if sys.version_info < (3, 6):
    raise Exception('Need at least Python 3.6 for this tool')
    # pathlib, f-strings

SCRIPT_DIR = pathlib.Path(__file__).absolute().parent

# FIXME: this is not fully XDG-compliant
_APP_NAME = pathlib.Path('tv')
_HOME_DIR = _APP_NAME.home()


def _xdg_dir(varname: str, home_rel_default: typing.Sequence[str]) -> pathlib.Path:
    ps = os.getenv(varname, None)
    if ps is None:
        p = _HOME_DIR
        for n in home_rel_default:
            p = p / n
    else:
        p = pathlib.Path(ps)
    return p / _APP_NAME


_CONFIG_DIR = _xdg_dir('XDG_CONFIG_HOME', ('.config',))      # read files: default.pin and default.hostname
_CACHE_DIR = _xdg_dir('XDG_CACHE_HOME', ('.cache',))         # keep a copy of the TV's public key for encryption
_DATA_DIR = _xdg_dir('XDG_DATA_HOME', ('.local', 'share',))  # keep our local private/public keys for encryption
_DEFAULT_TV = 'default'

DEF_USERAGENT = 'tv/0.2 (Phil Pennock)'
# This exists just for local disk and might as well be the empty string, but I
# don't want to fight APIs any more, so this is one generated password which
# I'm leaving in source, on the basis that it's like bouncycastle's "changeme"
# string: a password that's not a password, just a known serialization
# constant:
PRIVATE_KEY_PASSWORD = b'Wh#2#*4zbWBH0_o4x,Ad'


class Error(Exception):
    """Base class for exceptions from tv."""
    pass


class VolumeSpecParseError(Error):
    """Unparseable volume specification."""
    pass


class Exit(Exception):
    """Base class for exceptions which exit without a stack trace."""
    pass


class Config(pdpgeneric.VerboseObject):
    PIN_OPTION, PIN_FILEEXT = 'pin', 'pin'
    HOST_OPTION, HOST_FILEEXT = 'host', 'hostname'

    def __init__(self, options: argparse.Namespace) -> None:
        self.options = options
        super().__init__()
        self.verbose_tag_add('Config')
        # .tv is the config name as given, often 'default
        # .real_tv is the actual name, use this to write files
        self.tv = self.options.tv
        self.tv_pin = self.derive_field(Config.PIN_OPTION, Config.PIN_FILEEXT)
        self.tv_host = self.derive_field(Config.HOST_OPTION, Config.HOST_FILEEXT)
        self.using_default = self.tv == _DEFAULT_TV
        if self.using_default:
            self.real_tv = self._find_real_tvname()
        else:
            self.real_tv = self.tv
        self.verbose(f'host is {self.tv_host!r}')
        self.verbose(f'PIN is {self.tv_pin!r}', level=9)
        self.our_rsakey = None

    def derive_field(self, optname: str, base: str) -> str:
        t = getattr(self.options, optname)
        if t:
            return t
        return self.read_config(base)

    def read_config(self, base: str) -> str:
        fn = _CONFIG_DIR / (self.options.tv + '.' + base)
        return fn.read_text().strip()

    def _find_real_tvname(self) -> str:
        default_pin_file = _CONFIG_DIR / (_DEFAULT_TV + '.' + Config.PIN_FILEEXT)
        return default_pin_file.resolve().stem

    @property
    def tv_keyfile(self) -> pathlib.Path:
        return _CACHE_DIR / (self.real_tv + '.tv.rsa.pub')

    @property
    def our_public_keyfile(self) -> pathlib.Path:
        return _DATA_DIR / 'our.rsa.pub'

    @property
    def our_private_keyfile(self) -> pathlib.Path:
        return _DATA_DIR / 'our.rsa.private'

    def persist_current(self) -> None:
        write_name = self.options.new_tvname if self.options.new_tvname else self.real_tv
        forbidden = [os.path.sep, os.path.pathsep]
        if os.path.extsep:
            forbidden += [os.path.extsep]
        if True in [c in write_name for c in forbidden]:
            raise Error(f'bad characters in {write_name!r}')

        # We will write the derived merged values, so can modify an existing TV to a new name.

        if not _CONFIG_DIR.exists():
            _CONFIG_DIR.mkdir(mode=0o700, parents=True)

        default_pin_file = _CONFIG_DIR / (_DEFAULT_TV + '.' + Config.PIN_FILEEXT)
        default_host_file = _CONFIG_DIR / (_DEFAULT_TV + '.' + Config.HOST_FILEEXT)
        if write_name == _DEFAULT_TV:
            write_name = _DEFAULT_TV + '-real'
        pin_file = _CONFIG_DIR / (write_name + '.' + Config.PIN_FILEEXT)
        host_file = _CONFIG_DIR / (write_name + '.' + Config.HOST_FILEEXT)
        # Don't update defaults until both named entries have been written
        for f, content in [(pin_file, self.tv_pin), (host_file, self.tv_host)]:
            if f.exists():
                f.unlink()
            f.touch(mode=0o600, exist_ok=False)
            f.write_text(content + '\n', encoding='utf-8')
        # We have no locking here, so not safe against a concurrent reader.
        # For myself now, I don't currently care.
        for src, dest in [(default_pin_file, pin_file), (default_host_file, host_file)]:
            if src.exists() and not src.is_symlink():
                src.rename(src.with_suffix('.old' + src.suffix))
            if src.exists():
                src.unlink()
            src.symlink_to(dest.name)

    @dataclass
    class WrapCrypto:
        backend: typing.Any = cryptography.hazmat.backends.default_backend()
        DER: typing.Any = cryptography.hazmat.primitives.serialization.Encoding.DER
        PEM: typing.Any = cryptography.hazmat.primitives.serialization.Encoding.PEM
        PKCS1: typing.Any = cryptography.hazmat.primitives.serialization.PublicFormat.PKCS1
        PKCS8: typing.Any = cryptography.hazmat.primitives.serialization.PrivateFormat.PKCS8
        SPKI: typing.Any = cryptography.hazmat.primitives.serialization.PublicFormat.SubjectPublicKeyInfo
        PrivateRaw: typing.Any = cryptography.hazmat.primitives.serialization.PrivateFormat.Raw
        # NoEncryption apparently does not satisfy KeySerializationEncryption
        # I want one fixed serialization type so I can safely load, but
        # cryptography only lets me have access to the mutable curated choice.
        BestAvailableEncryption: typing.Any = cryptography.hazmat.primitives.serialization.BestAvailableEncryption
        want_exponent: int = 65537
        want_keysize: int = 2048

    Crypto = WrapCrypto()

    def load_pubkey_b64(self, b64data: str) -> cryptography.hazmat.primitives.asymmetric.rsa.RSAPublicKey:
        return self.load_pubkey_bin(self, base64.b64decode(b64data, validate=True))

    def load_pubkey_bin(self, bindata: str) -> cryptography.hazmat.primitives.asymmetric.rsa.RSAPublicKey:
        return cryptography.hazmat.primitives.serialization.load_der_public_key(bindata, backend=self.Crypto.backend)

    def make_rsa_key(self) -> cryptography.hazmat.primitives.asymmetric.rsa.RSAPrivateKey:
        return cryptography.hazmat.primitives.asymmetric.rsa.generate_private_key(
            public_exponent=self.Crypto.want_exponent,
            key_size=self.Crypto.want_keysize,
            backend=self.Crypto.backend)

    def write_file(self, fpath: pathlib.Path, data: bytes) -> None:
        if not fpath.parent.exists():
            fpath.parent.mkdir(0o700)
        if fpath.exists():
            saved = fpath.with_suffix('.old' + fpath.suffix)
            if saved.exists():
                saved.unlink()
            fpath.rename(saved)
        fpath.touch(mode=0o600, exist_ok=False)
        fpath.write_bytes(data)

    def save_our_private_key(self, rsakey: cryptography.hazmat.primitives.asymmetric.rsa.RSAPrivateKey) -> None:
        self.write_file(
            self.our_private_keyfile,
            rsakey.private_bytes(
                encoding=self.Crypto.PEM,
                format=self.Crypto.PKCS8,
                encryption_algorithm=self.Crypto.BestAvailableEncryption(PRIVATE_KEY_PASSWORD)),
        )

    def save_our_public_key(self, rsakey: cryptography.hazmat.primitives.asymmetric.rsa.RSAPrivateKey) -> None:
        # We don't use this ourselves, we do this so that other tooling can look at it if wanted.
        self.write_file(
            self.our_public_keyfile,
            rsakey.public_key().public_bytes(self.Crypto.PEM, self.Crypto.PKCS1),
        )

    def setup_thisremote_encryption(self, force_new_remote_key=False) -> None:
        if self.our_private_keyfile.exists() and not force_new_remote_key:
            self.our_rsakey = cryptography.hazmat.primitives.serialization.load_pem_private_key(
                self.our_private_keyfile.read_bytes(),
                password=PRIVATE_KEY_PASSWORD,
                backend=self.Crypto.backend)
        else:
            self.our_rsakey = self.make_rsa_key()
            self.save_our_public_key(self.our_rsakey)
            self.save_our_private_key(self.our_rsakey)


class Remote(pdpgeneric.VerboseObject):
    def __init__(self, config: Config) -> None:
        self.options = config.options
        super().__init__()
        self.verbose_tag_add('Remote')
        self.config = config
        self.next_id = 1
        self.addr = config.tv_host
        self.pin = config.tv_pin
        self._tv_pubkey_b64 = None
        self._tv_pubkey_bin = None
        self._setup_requests()

    def _setup_requests(self) -> None:
        self.session = requests.Session()
        self.session.headers['User-Agent'] = DEF_USERAGENT
        self.session.headers['X-Auth-PSK'] = self.pin

    def _send(self, service: str, method: str, params: typing.Dict, *, api_version='1.0'):
        url = f'http://{self.addr}/sony/{service}'
        payload_d = {
            'method': method,
            'version': api_version,
            'id': self.next_id,
            'params': [params] if params else [],
        }
        self.next_id += 1
        if self.options.verbose >= 3:
            print(f'POST <{url}> ', end='')
            pretty_print_json(payload_d)
        elif self.options.verbose >= 2:
            print(f' >> {service} / {method}')
        r = self.session.post(url, json=payload_d)
        return r

    def send(self, service: str, method: str, params: typing.Dict, **kwargs) -> None:
        r = self._send(service, method, params, **kwargs)
        if self.options.verbose:
            pretty_print_json(r.json())

    def query(self, service: str, method: str, params: typing.Dict, **kwargs) -> typing.Dict:
        return self._send(service, method, params, **kwargs).json()

    # <https://pro-bravia.sony.net/develop/integrate/rest-api/spec/>
    KNOWN_SERVICES = 'guide appControl audio avContent encryption system videoScreen'.split()

    def _get_power(self) -> str:
        resp = self.query('system', 'getPowerStatus', {})
        return resp['result'][0]['status']

    def _set_power(self, power_state: bool) -> None:
        self.send('system', 'setPowerStatus', {'status': power_state})

    power = property(_get_power, _set_power, None)

    def _set_mute(self, mute_state: bool) -> None:
        self.send('audio', 'setAudioMute', {'status': mute_state})

    mute = property(None, _set_mute, None)

    # this is paired with :playing, query_playing_content_info()
    # might build a map of uris to labels and try to simplify through that, for a better reader?
    def set_external_input(self, kind: str, port: str) -> None:
        uri = f'extInput:{kind}?port={port}'
        self.send('avContent', 'setPlayContent', {'uri': uri})

    def _get_volume(self) -> typing.List[typing.Dict]:
        resp = self.query('audio', 'getVolumeInformation', {})
        return resp['result'][0]

    def _set_volume(self, new_volume: str) -> None:
        # api 1.2 lets us control if the on-screen volume UI should be displayed; stick to 1.0, accept UI defaults
        self.send('audio', 'setAudioVolume', {'target': 'speaker', 'volume': new_volume})

    volume = property(_get_volume, _set_volume, None)

    def reboot(self) -> None:
        self.send('system', 'requestReboot', {})

    def list_apps(self) -> typing.List[str]:
        apps = self.query('appControl', 'getApplicationList', {})
        return [html.unescape(x['title']) for x in apps['result'][0]]

    def launch_app(self, appname: str) -> None:
        needle = appname.lower()
        res = self.query('appControl', 'getApplicationList', {})
        filtered = [app for app in res['result'][0] if html.unescape(app['title']).lower() == needle]
        if not filtered:
            raise Exit(f'unknown app {appname!r}')
        if len(filtered) > 1:
            applist = ', '.join(map(lambda x: shlex.quote(html.unescape(x['title'])), filtered))
            raise Exit(f'too many apps found for {appname!r}: {applist}')
        uri = filtered[0]['uri']
        self.send('appControl', 'setActiveApp', {'uri': uri})

    def list_inputs(self) -> typing.List[typing.Dict]:
        inputs = self.query('avContent', 'getCurrentExternalInputsStatus', {}, api_version='1.1')
        return inputs['result'][0]

    # All methods with names starting 'query_' are directly exposed by the
    # Commander as debug commands, specified with a leading colon,
    # thus `tv :query_time` works.

    def query_supported_apis(self) -> None:
        pretty_print_json(self.query('guide', 'getSupportedApiInfo', {'services': Remote.KNOWN_SERVICES}))

    def query_time(self) -> None:
        pretty_print_json(self.query('system', 'getCurrentTime', {}, api_version='1.1'))

    def query_network_settings(self) -> None:
        # We shouldn't need netif per the spec, but we get "Illegal Argument" without it
        pretty_print_json(self.query('system', 'getNetworkSettings', {'netif': ''}))

    def query_interface_information(self) -> None:
        pretty_print_json(self.query('system', 'getInterfaceInformation', {})['result'][0])

    def query_sound_settings(self) -> None:
        # Array, one for each target
        pretty_print_json(self.query('audio', 'getSoundSettings', {'target': ''}, api_version='1.1')['result'][0])

    def query_speaker_settings(self) -> None:
        # Array, one for each target
        pretty_print_json(self.query('audio', 'getSpeakerSettings', {'target': ''})['result'][0])

    def query_playing_content_info(self) -> None:
        pretty_print_json(self.query('avContent', 'getPlayingContentInfo', {})['result'][0])

    def setup_encryption(self, force_fetch=False, tv_only=False, **kwargs) -> None:
        if not tv_only:
            self.config.setup_thisremote_encryption(**kwargs)
        if self.config.tv_keyfile.exists() and not force_fetch:
            self._tv_pubkey_b64 = self.config.tv_keyfile.read_bytes().strip()
        else:
            kd = self.query('encryption', 'getPublicKey', {})
            self._tv_pubkey_b64 = kd['result'][0]['publicKey']
            if not self.config.tv_keyfile.parent.exists():
                self.config.tv_keyfile.parent.mkdir(0o700)
            self.config.tv_keyfile.write_text(self._tv_pubkey_b64 + '\n')
        self._tv_pubkey_bin = base64.b64decode(self._tv_pubkey_b64, validate=True)

    @property
    def tv_pubkey(self) -> bytes:
        if self._tv_pubkey_bin is None:
            self.setup_encryption(tv_only=True)
        return self.config.load_pubkey_bin(self._tv_pubkey_bin)


class Commander(pdpgeneric.VerboseObject):
    def __init__(self, remote: Remote, commands: typing.List[str]) -> None:
        self.options = remote.options
        super().__init__()
        self.verbose_tag_add('Commander')
        self.remote = remote
        self.commands = commands
        self.vol_matcher = re.compile(r'^([+-])(\d+)\Z')

    def next(self, previous: str) -> str:
        try:
            return self.commands.pop(0)
        except IndexError:
            raise Exit(f'parameter needed for command {previous!r}')

    def volume(self, spec: str, allow_absolute: bool) -> None:
        m = self.vol_matcher.match(spec)
        if m:
            if int(m.group(2)) > 10:
                raise Exit('can only raise/lower by up to ±10')
            self.remote.volume = spec
            return

        if not allow_absolute:
            raise VolumeSpecParseError(f'unhandled volume spec {spec!r}')
        ivol = int(spec)
        if ivol > 100:
            raise Exit('can only set volume to absolute 0..100')
        self.remote.volume = str(ivol)

    def one(self, command: str) -> None:
        remote = self.remote
        if command == 'on':
            remote.power = True
            return
        elif command == 'off':
            remote.power = False
            return
        elif command in ('power', '?power'):
            print(remote.power)
            return
        elif command == 'mute':
            remote.mute = True
            return
        elif command == 'unmute':
            remote.mute = False
            return
        elif command in ('hdmi', 'composite', 'scart'):
            try:
                port = str(int(self.next(command)))
            except Exit:
                raise Exit(f'command {command} needs a port (1..4)')
            # The actual limit might happen to be 4, but if we want to
            # _enforce_ then don't hard-code;
            # remote.send('avContent', 'getContentCount', {'source': 'extInput:hdmi'})
            # _should_ give us r['result'][0]['count']; I don't want an extra
            # RPC call for static data, so instead punt on enforcing this until
            # such time as we suck it up and build a capabilities cache in XDG
            # storage.
            remote.set_external_input(command, port)
            return
        elif command in ('vol', 'volume'):
            self.volume(self.next(command), True)
            return
        elif command in ('get-vol', 'get-volume', '?vol', '?volume'):
            pretty_print_json(remote.volume)
            return
        elif command == 'app':
            remote.launch_app(self.next(command))
            return

        elif command in ('apps', '?apps', 'list-apps'):
            for app in sorted(remote.list_apps()):
                print(f' • {app}')
            return
        elif command in ('list-inputs', '?inputs'):
            maxlen_title, maxlen_label = 1, 1
            for inp in remote.list_inputs():
                tl, ll = len(inp['title']), len(inp['label'])
                if tl > maxlen_title:
                    maxlen_title = tl
                if ll > maxlen_label:
                    maxlen_label = ll
            spec = '{title:<%d}  {label:<%d}  {uri}' % (maxlen_title, maxlen_label)
            for inp in remote.list_inputs():
                print(spec.format(**inp))
            return

        elif command == 'danger-reboot':
            remote.reboot()
            return

        # Keep :foo for internals and debug
        elif command == ':about':
            remote.query_interface_information()
            return
        elif command == ':playing':
            remote.query_playing_content_info()
            return
        elif command.startswith(':query_') and hasattr(remote, command[1:]):
            getattr(remote, command[1:])()
            return
        elif command == ':query':
            known = [x for x in dir(remote) if x.startswith('query_')]
            for cmd in sorted(known):
                print(':', cmd, sep='')
            return

        elif command in ('help', '?help', ':help'):
            print('''tv: <one or more commands>
 on       off           ?power
 mute     unmute
 vol +n   vol -n        vol NN      ?vol
 hdmi N   composite N   scart N
 list-inputs
 list-apps       - list installed applications
 app NAME        - launch app NAME
 danger-reboot   - reboots the TV
 :about          - basic information about the TV
 :playing        - current input source
 :query          - list various :query_* debug commands
''')
            return

        try:
            self.volume(command, False)
            return
        except VolumeSpecParseError:
            pass

        raise Exit(f'Unknown command {command!r}')

    def loop(self) -> None:
        is_subsequent = False
        while self.commands:
            if is_subsequent:
                time.sleep(0.5)
            else:
                is_subsequent = True
            self.one(self.next('').lower())


def _setup_cli_parser() -> argparse.ArgumentParser:
    parser = argparse.ArgumentParser(
        description=__doc__,
        formatter_class=argparse.RawDescriptionHelpFormatter)
    parser.add_argument('-t', '--tv',
                        type=str, default=_DEFAULT_TV,
                        help='Override configuration name for TV [%(default)s]')
    parser.add_argument('-H', '--host',
                        type=str, default='',
                        help='Override TV host/IP [%(default)s]')
    parser.add_argument('--pin',
                        type=str, default='',
                        help='override PIN from config')
    parser.add_argument('-w', '--write',
                        action='store_true', default=False,
                        help='Write out config from flags, make default')
    parser.add_argument('--new-tvname',
                        type=str, default='',
                        help='With -w use a new name instead of --tv for the config')
    parser.add_argument('-E', '--setup-encryption',
                        action='store_true', default=False,
                        help='Preemptively setup encryption')
    parser.add_argument('-v', '--verbose',
                        action='count', default=0,
                        help='Be more verbose')
    parser.add_argument('rest', nargs='+', metavar='Command',
                        help='TV commands to issue (try :help)')
    return parser


def _main(args: typing.List[str], argv0: str) -> int:
    parser = _setup_cli_parser()
    options = parser.parse_args(args=args)

    config = Config(options)
    if options.write:
        config.persist_current()

    remote = Remote(config)
    if options.setup_encryption:
        remote.setup_encryption()

    commander = Commander(remote, options.rest)
    commander.loop()
    return 0


if __name__ == '__main__':
    argv0 = pathlib.Path(sys.argv[0]).name
    if argv0.endswith('.py'):
        argv0 = argv0[:-3]
    tracer = None

    def _start(): return _main(sys.argv[1:], argv0=argv0)
    start = _start
    rv = 0
    if os.environ.get('TRACE_' + argv0.upper(), None):
        ignore = [sys.prefix, sys.exec_prefix]
        if 'PYENV_ROOT' in os.environ:
            ignore.append(os.environ['PYENV_ROOT'])
        import trace
        tracer = trace.Trace(
            ignoredirs=ignore,
            count=0,  # skip .cover generation
        )

        def start(): return tracer.run('_start()')
    try:
        rv = start()
    except Exit as e:
        for arg in e.args:
            print('{}: {}'.format(argv0, arg), file=sys.stderr)
        sys.exit(1)
    finally:
        if tracer:
            tracer.results().write_results()
    sys.exit(rv)

# Debugging:
# import pathlib; __name__, __file__ = 'debug-tv', 'tv'; exec(pathlib.Path('~/tools/site/common/tv').expanduser().read_text())
if __name__ == 'debug-tv':
    parser = _setup_cli_parser()
    options = parser.parse_args(args=[':help'])
    config = Config(options)
    remote = Remote(config)

# vim: set ft=python sw=4 expandtab :
